# 9. 预处理脚本

## 功能概述
系统需要支持接入 JavaScript 脚本，并提供脚本执行环境。脚本分为两类：
- 发送前处理：在消息发布前对 payload 进行处理
- 接收后处理：在收到消息后对 payload 进行处理

## 功能需求

### 9.1 脚本管理
- 脚本按服务器配置，每个服务器独立管理脚本
- 提供脚本管理入口（在命令栏"管理模板"右侧添加"管理脚本"按钮）
- 脚本管理弹窗包含：
  - 左侧：脚本列表（支持启用/禁用开关）
  - 右侧：脚本编辑区（名称、类型、描述、代码）

### 9.2 脚本类型
1. **发送前处理（before_publish）**
   - 在发布消息时，对待发送的 payload 进行处理
   - 函数签名：`process(payload) -> payload`
   - 应用场景：数据格式化、加密、添加前缀等

2. **接收后处理（after_receive）**
   - 在收到消息后，对收到的 payload 进行处理
   - 函数签名：`process(payload, topic) -> payload`
   - 应用场景：数据解析、解密、格式化展示等

### 9.3 脚本执行引擎
- 使用 JavaScript 沙箱环境执行脚本
- 提供安全的执行上下文，限制访问范围
- 支持基础 API：JSON、String、Number、Array、Object、Date、Math 等
- 支持编码函数：btoa、atob、encodeURIComponent、decodeURIComponent
- 支持 console 输出（用于调试）
- 支持加密工具（crypto 对象）

### 9.4 脚本模板
创建脚本时提供默认模板代码：

**发送前处理模板：**
```javascript
// 发送前处理脚本
// payload: 待发送的消息内容 (字符串)
// 返回值: 处理后的消息内容 (字符串)

function process(payload) {
  // 在这里处理 payload
  return payload;
}
```

**接收后处理模板：**
```javascript
// 接收后处理脚本
// payload: 接收到的消息内容 (字符串)
// topic: 消息主题 (字符串)
// 返回值: 处理后的消息内容 (字符串)

function process(payload, topic) {
  // 在这里处理接收到的消息
  return payload;
}
```

## 技术实现

### 后端 (Rust)
- 数据模型：Script（id, server_id, name, script_type, code, enabled, description）
- 存储：使用 YAML 文件存储脚本配置
- API：list_scripts, get_script, get_enabled_scripts, create_script, update_script, delete_script, toggle_script

### 前端 (Vue)
- ScriptDialog.vue：脚本管理对话框组件
- script.ts：脚本状态管理 Store
- scriptEngine.ts：脚本执行引擎（使用 new Function 创建沙箱）
- 集成点：PublishPanel、ScheduledPublishDialog、mqtt.ts 消息监听

## 加密工具 API

脚本中可通过 `crypto` 对象访问以下加密工具：

### 编码转换
| 函数 | 说明 |
|------|------|
| `crypto.stringToBytes(str)` | 字符串转 Uint8Array |
| `crypto.bytesToString(bytes)` | Uint8Array 转字符串 |
| `crypto.bytesToBase64(bytes)` | Uint8Array 转 Base64 |
| `crypto.base64ToBytes(str)` | Base64 转 Uint8Array |
| `crypto.bytesToHex(bytes)` | Uint8Array 转十六进制 |
| `crypto.hexToBytes(hex)` | 十六进制转 Uint8Array |

### 随机数生成
| 函数 | 说明 |
|------|------|
| `crypto.randomBytes(length)` | 生成指定长度的随机字节 |
| `crypto.generateKey(bits)` | 生成随机密钥（Base64），默认128位 |
| `crypto.generateIv(length)` | 生成随机IV（Base64），默认12字节 |

### 哈希函数
| 函数 | 说明 |
|------|------|
| `await crypto.sha256(data)` | SHA-256 哈希（返回十六进制） |
| `await crypto.sha1(data)` | SHA-1 哈希（返回十六进制） |
| `crypto.md5(data)` | MD5 哈希（返回十六进制） |
| `await crypto.hmacSha256(key, data)` | HMAC-SHA256（返回十六进制） |

### AES 加解密（Base64 格式）
| 函数 | 说明 |
|------|------|
| `await crypto.aesGcmEncrypt(text, keyBase64, ivBase64?)` | AES-GCM 加密，返回 Base64 |
| `await crypto.aesGcmDecrypt(cipherBase64, keyBase64)` | AES-GCM 解密，返回明文 |
| `await crypto.aesCbcEncrypt(text, keyBase64, ivBase64?)` | AES-CBC 加密，返回 Base64 |
| `await crypto.aesCbcDecrypt(cipherBase64, keyBase64)` | AES-CBC 解密，返回明文 |

### AES 加解密（Hex 格式）
| 函数 | 说明 |
|------|------|
| `await crypto.aesGcmEncryptHex(text, keyHex, ivHex?)` | AES-GCM 加密，密钥/IV 为 Hex 格式，返回 Hex |
| `await crypto.aesGcmDecryptHex(cipherHex, keyHex)` | AES-GCM 解密，密钥/密文为 Hex 格式，返回明文 |
| `await crypto.aesCbcEncryptHex(text, keyHex, ivHex?)` | AES-CBC 加密，密钥/IV 为 Hex 格式，返回 Hex |
| `await crypto.aesCbcDecryptHex(cipherHex, keyHex)` | AES-CBC 解密，密钥/密文为 Hex 格式，返回明文 |

### 其他工具
| 函数 | 说明 |
|------|------|
| `crypto.xor(data, key)` | XOR 加解密（对称） |
| `crypto.crc32(data)` | CRC32 校验（返回十六进制） |

### 使用示例

**AES-GCM 加密示例：**
```javascript
async function process(payload) {
  // 生成密钥（实际使用时应固定密钥）
  const key = 'MTIzNDU2Nzg5MDEyMzQ1Ng=='; // 16字节密钥的Base64
  
  // 加密
  const encrypted = await crypto.aesGcmEncrypt(payload, key);
  return encrypted;
}
```

**AES-GCM 解密示例：**
```javascript
async function process(payload, topic) {
  const key = 'MTIzNDU2Nzg5MDEyMzQ1Ng==';
  
  // 解密
  const decrypted = await crypto.aesGcmDecrypt(payload, key);
  return decrypted;
}
```

**AES-GCM 加密示例（Hex 格式）：**
```javascript
async function process(payload) {
  // 128位密钥（32个十六进制字符 = 16字节）
  const key = '8568200E4BBAF3A000B6F510A38717D5';
  // 12字节 IV（24个十六进制字符）
  const nonce = '0CA00E0BA0BE0000CE0DB0AD';
  
  // 加密，返回 Hex 格式密文
  const encrypted = await crypto.aesGcmEncryptHex(payload, key, nonce);
  return encrypted;
}
```

**AES-GCM 解密示例（Hex 格式）：**
```javascript
async function process(payload, topic) {
  const key = '8568200E4BBAF3A000B6F510A38717D5';
  
  // 解密 Hex 格式密文
  const decrypted = await crypto.aesGcmDecryptHex(payload, key);
  return decrypted;
}
```