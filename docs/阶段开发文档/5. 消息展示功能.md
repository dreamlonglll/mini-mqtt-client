# 阶段五：消息展示功能

## 概述

本阶段实现 MQTT 消息的展示功能，包括实时消息流、消息格式化、消息过滤和搜索等。

## 任务清单

### 5.1 消息列表展示

- [ ] 实现消息列表组件
- [ ] 区分发布/接收消息
- [ ] 实现消息时间戳显示
- [ ] 实现消息方向指示

### 5.2 消息格式化展示

- [ ] JSON 格式化高亮显示
- [ ] HEX 格式化显示
- [ ] 纯文本显示
- [ ] 实现格式切换

### 5.3 消息过滤与搜索

- [ ] 按主题过滤
- [ ] 按时间范围过滤
- [ ] 关键词搜索
- [ ] 按方向过滤（发布/接收）

### 5.4 消息详情

- [ ] 消息详情弹窗
- [ ] 复制消息功能
- [ ] 重新发布功能

---

## 详细实现

### 5.1 消息列表组件

**文件：`src/components/mqtt/MessageList.vue`**

```vue
<template>
  <div class="message-list">
    <div class="message-header">
      <div class="header-left">
        <span class="title">消息记录</span>
        <el-tag size="small" type="info">{{ filteredMessages.length }}</el-tag>
      </div>
      <div class="header-right">
        <el-input
          v-model="searchKeyword"
          placeholder="搜索消息..."
          prefix-icon="Search"
          size="small"
          style="width: 200px"
          clearable
        />
        <el-dropdown @command="handleFilterCommand">
          <el-button size="small">
            筛选
            <el-icon class="el-icon--right"><ArrowDown /></el-icon>
          </el-button>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item command="all">全部</el-dropdown-item>
              <el-dropdown-item command="publish">仅发布</el-dropdown-item>
              <el-dropdown-item command="receive">仅接收</el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
        <el-button size="small" @click="handleClear" type="danger" text>
          清空
        </el-button>
      </div>
    </div>

    <div class="message-container" ref="containerRef">
      <div v-if="filteredMessages.length === 0" class="empty-state">
        <el-empty description="暂无消息" />
      </div>
      
      <div
        v-for="message in filteredMessages"
        :key="message.id"
        class="message-item"
        :class="[message.direction]"
        @click="showDetail(message)"
      >
        <div class="message-meta">
          <el-icon :class="message.direction">
            <Top v-if="message.direction === 'publish'" />
            <Bottom v-else />
          </el-icon>
          <span class="topic">{{ message.topic }}</span>
          <el-tag size="small" :type="getQosTagType(message.qos)">
            QoS {{ message.qos }}
          </el-tag>
          <el-tag v-if="message.retain" size="small" type="warning">
            Retain
          </el-tag>
          <span class="time">{{ formatTime(message.created_at) }}</span>
        </div>
        <div class="message-payload">
          <MessagePayload
            :payload="message.payload"
            :format="message.payload_format"
            :preview="true"
          />
        </div>
      </div>
    </div>

    <!-- 消息详情对话框 -->
    <el-dialog
      v-model="showDetailDialog"
      :title="selectedMessage?.topic || '消息详情'"
      width="600px"
    >
      <div v-if="selectedMessage" class="message-detail">
        <el-descriptions :column="2" border>
          <el-descriptions-item label="方向">
            {{ selectedMessage.direction === 'publish' ? '发布' : '接收' }}
          </el-descriptions-item>
          <el-descriptions-item label="QoS">
            {{ selectedMessage.qos }}
          </el-descriptions-item>
          <el-descriptions-item label="Retain">
            {{ selectedMessage.retain ? '是' : '否' }}
          </el-descriptions-item>
          <el-descriptions-item label="格式">
            {{ formatLabel(selectedMessage.payload_format) }}
          </el-descriptions-item>
          <el-descriptions-item label="时间" :span="2">
            {{ formatFullTime(selectedMessage.created_at) }}
          </el-descriptions-item>
          <el-descriptions-item label="主题" :span="2">
            <code>{{ selectedMessage.topic }}</code>
          </el-descriptions-item>
        </el-descriptions>

        <div class="payload-section">
          <div class="payload-header">
            <span>消息内容</span>
            <div class="payload-actions">
              <el-button size="small" text @click="copyPayload">
                复制
              </el-button>
              <el-button size="small" text @click="republish">
                重新发布
              </el-button>
            </div>
          </div>
          <MessagePayload
            :payload="selectedMessage.payload"
            :format="selectedMessage.payload_format"
            :preview="false"
          />
        </div>
      </div>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, nextTick } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { Top, Bottom, ArrowDown } from '@element-plus/icons-vue'
import { useMessageStore } from '@/stores/message'
import MessagePayload from './MessagePayload.vue'
import type { MessageHistory } from '@/types/mqtt'

const props = defineProps<{
  serverId: number
}>()

const emit = defineEmits<{
  republish: [message: MessageHistory]
}>()

const messageStore = useMessageStore()
const containerRef = ref<HTMLElement>()

const searchKeyword = ref('')
const directionFilter = ref<'all' | 'publish' | 'receive'>('all')
const showDetailDialog = ref(false)
const selectedMessage = ref<MessageHistory | null>(null)

const messages = computed(() => messageStore.getMessages(props.serverId))

const filteredMessages = computed(() => {
  let result = messages.value

  // 方向过滤
  if (directionFilter.value !== 'all') {
    result = result.filter(m => m.direction === directionFilter.value)
  }

  // 关键词搜索
  if (searchKeyword.value.trim()) {
    const keyword = searchKeyword.value.toLowerCase()
    result = result.filter(m => 
      m.topic.toLowerCase().includes(keyword) ||
      m.payload.toLowerCase().includes(keyword)
    )
  }

  return result
})

// 自动滚动到底部
watch(messages, async () => {
  await nextTick()
  if (containerRef.value) {
    containerRef.value.scrollTop = 0
  }
})

function handleFilterCommand(command: string) {
  directionFilter.value = command as 'all' | 'publish' | 'receive'
}

async function handleClear() {
  try {
    await ElMessageBox.confirm('确定要清空所有消息记录吗？', '确认清空', {
      type: 'warning',
    })
    await messageStore.clearHistory(props.serverId)
    ElMessage.success('已清空消息记录')
  } catch {
    // 用户取消
  }
}

function showDetail(message: MessageHistory) {
  selectedMessage.value = message
  showDetailDialog.value = true
}

function copyPayload() {
  if (selectedMessage.value) {
    navigator.clipboard.writeText(selectedMessage.value.payload)
    ElMessage.success('已复制到剪贴板')
  }
}

function republish() {
  if (selectedMessage.value) {
    emit('republish', selectedMessage.value)
    showDetailDialog.value = false
  }
}

function formatTime(timestamp: string) {
  const date = new Date(timestamp)
  return date.toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}

function formatFullTime(timestamp: string) {
  const date = new Date(timestamp)
  return date.toLocaleString('zh-CN')
}

function formatLabel(format: string) {
  const labels: Record<string, string> = {
    text: '纯文本',
    json: 'JSON',
    hex: 'HEX',
  }
  return labels[format] || format
}

function getQosTagType(qos: number) {
  const types = ['info', 'success', 'warning'] as const
  return types[qos] || 'info'
}
</script>

<style scoped>
.message-list {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: var(--el-bg-color);
}

.message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--el-border-color);
}

.header-left {
  display: flex;
  align-items: center;
  gap: 8px;
}

.title {
  font-weight: 600;
  font-size: 14px;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 8px;
}

.message-container {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.empty-state {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.message-item {
  padding: 12px;
  margin-bottom: 8px;
  border-radius: 8px;
  background-color: var(--el-fill-color-light);
  cursor: pointer;
  transition: all 0.2s;
}

.message-item:hover {
  background-color: var(--el-fill-color);
}

.message-item.publish {
  border-left: 3px solid var(--el-color-primary);
}

.message-item.receive {
  border-left: 3px solid var(--el-color-success);
}

.message-meta {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 12px;
}

.message-meta .el-icon.publish {
  color: var(--el-color-primary);
}

.message-meta .el-icon.receive {
  color: var(--el-color-success);
}

.topic {
  font-family: monospace;
  font-weight: 500;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.time {
  color: var(--el-text-color-secondary);
  margin-left: auto;
}

.message-payload {
  max-height: 80px;
  overflow: hidden;
}

.message-detail {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.payload-section {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.payload-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
}

.payload-actions {
  display: flex;
  gap: 8px;
}
</style>
```

### 5.2 消息内容展示组件

**文件：`src/components/mqtt/MessagePayload.vue`**

```vue
<template>
  <div class="message-payload" :class="{ preview }">
    <div v-if="format === 'json'" class="json-content">
      <pre v-if="formattedJson">{{ formattedJson }}</pre>
      <span v-else class="invalid-json">{{ payload }}</span>
    </div>
    
    <div v-else-if="format === 'hex'" class="hex-content">
      <div class="hex-display">
        <div class="hex-row" v-for="(row, index) in hexRows" :key="index">
          <span class="offset">{{ formatOffset(index * 16) }}</span>
          <span class="hex-bytes">
            <span
              v-for="(byte, i) in row.bytes"
              :key="i"
              class="byte"
            >
              {{ byte }}
            </span>
          </span>
          <span class="ascii">{{ row.ascii }}</span>
        </div>
      </div>
    </div>
    
    <div v-else class="text-content">
      {{ payload }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  payload: string
  format: 'text' | 'json' | 'hex'
  preview?: boolean
}>()

const formattedJson = computed(() => {
  if (props.format !== 'json') return null
  try {
    const parsed = JSON.parse(props.payload)
    return JSON.stringify(parsed, null, 2)
  } catch {
    return null
  }
})

const hexRows = computed(() => {
  if (props.format !== 'hex') return []
  
  // 解析 HEX 字符串为字节数组
  const cleanHex = props.payload.replace(/\s/g, '')
  const bytes: string[] = []
  
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes.push(cleanHex.substr(i, 2).toUpperCase())
  }
  
  // 分割成每行 16 字节
  const rows: { bytes: string[]; ascii: string }[] = []
  for (let i = 0; i < bytes.length; i += 16) {
    const rowBytes = bytes.slice(i, i + 16)
    const ascii = rowBytes
      .map(b => {
        const code = parseInt(b, 16)
        return code >= 32 && code <= 126 ? String.fromCharCode(code) : '.'
      })
      .join('')
    
    rows.push({ bytes: rowBytes, ascii })
  }
  
  return rows
})

function formatOffset(offset: number) {
  return offset.toString(16).toUpperCase().padStart(8, '0')
}
</script>

<style scoped>
.message-payload {
  font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.5;
}

.message-payload.preview {
  max-height: 60px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.json-content pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-all;
  color: var(--el-color-primary);
}

.invalid-json {
  color: var(--el-color-danger);
}

.hex-content {
  overflow-x: auto;
}

.hex-display {
  display: table;
  width: 100%;
}

.hex-row {
  display: table-row;
}

.hex-row > span {
  display: table-cell;
  padding: 2px 8px;
}

.offset {
  color: var(--el-text-color-secondary);
  width: 80px;
}

.hex-bytes {
  color: var(--el-color-primary);
}

.hex-bytes .byte {
  margin-right: 4px;
}

.hex-bytes .byte:nth-child(8n) {
  margin-right: 12px;
}

.ascii {
  color: var(--el-color-success);
  white-space: pre;
}

.text-content {
  white-space: pre-wrap;
  word-break: break-all;
}
</style>
```

### 5.3 消息事件处理

**文件：`src-tauri/src/mqtt/events.rs`**

```rust
use serde::{Deserialize, Serialize};
use tauri::{AppHandle, Emitter};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MqttMessageEvent {
    pub server_id: String,
    pub topic: String,
    pub payload: Vec<u8>,
    pub payload_string: String,
    pub qos: u8,
    pub retain: bool,
    pub timestamp: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MqttConnectionEvent {
    pub server_id: String,
    pub status: String, // "connected" | "disconnected" | "error"
    pub message: Option<String>,
}

pub fn emit_message_event(app: &AppHandle, event: MqttMessageEvent) {
    let _ = app.emit("mqtt:message", event);
}

pub fn emit_connection_event(app: &AppHandle, event: MqttConnectionEvent) {
    let _ = app.emit("mqtt:connection", event);
}
```

### 5.4 前端事件监听

**文件：`src/composables/useMqttEvents.ts`**

```typescript
import { onMounted, onUnmounted } from 'vue'
import { listen, UnlistenFn } from '@tauri-apps/api/event'
import { useMessageStore } from '@/stores/message'
import { useMqttStore } from '@/stores/mqtt'
import type { MessageHistory } from '@/types/mqtt'

interface MqttMessageEvent {
  server_id: string
  topic: string
  payload: number[]
  payload_string: string
  qos: number
  retain: boolean
  timestamp: string
}

interface MqttConnectionEvent {
  server_id: string
  status: 'connected' | 'disconnected' | 'error'
  message?: string
}

export function useMqttEvents() {
  const messageStore = useMessageStore()
  const mqttStore = useMqttStore()
  
  let unlistenMessage: UnlistenFn | null = null
  let unlistenConnection: UnlistenFn | null = null

  async function setupListeners() {
    // 监听消息事件
    unlistenMessage = await listen<MqttMessageEvent>('mqtt:message', (event) => {
      const { server_id, topic, payload_string, qos, retain, timestamp } = event.payload
      
      const message: MessageHistory = {
        id: Date.now(), // 临时 ID
        server_id: parseInt(server_id),
        topic,
        payload: payload_string,
        payload_format: detectFormat(payload_string),
        direction: 'receive',
        qos,
        retain,
        created_at: timestamp,
      }
      
      messageStore.addMessage(parseInt(server_id), message)
    })

    // 监听连接事件
    unlistenConnection = await listen<MqttConnectionEvent>('mqtt:connection', (event) => {
      const { server_id, status, message } = event.payload
      mqttStore.updateConnectionStatus(parseInt(server_id), status)
      
      if (message) {
        console.log(`[MQTT] ${server_id}: ${message}`)
      }
    })
  }

  function detectFormat(payload: string): 'text' | 'json' | 'hex' {
    // 尝试解析为 JSON
    try {
      JSON.parse(payload)
      return 'json'
    } catch {
      // 不是 JSON
    }
    
    // 检查是否看起来像 HEX
    if (/^[0-9a-fA-F\s]+$/.test(payload) && payload.length % 2 === 0) {
      return 'hex'
    }
    
    return 'text'
  }

  function cleanup() {
    unlistenMessage?.()
    unlistenConnection?.()
  }

  onMounted(() => {
    setupListeners()
  })

  onUnmounted(() => {
    cleanup()
  })

  return {
    setupListeners,
    cleanup,
  }
}
```

### 5.5 消息过滤工具栏组件

**文件：`src/components/mqtt/MessageFilter.vue`**

```vue
<template>
  <div class="message-filter">
    <el-form :inline="true" :model="filters" size="small">
      <el-form-item label="主题">
        <el-input
          v-model="filters.topic"
          placeholder="筛选主题"
          clearable
          style="width: 180px"
          @input="emitChange"
        />
      </el-form-item>
      
      <el-form-item label="方向">
        <el-select
          v-model="filters.direction"
          placeholder="全部"
          style="width: 100px"
          @change="emitChange"
        >
          <el-option label="全部" value="" />
          <el-option label="发布" value="publish" />
          <el-option label="接收" value="receive" />
        </el-select>
      </el-form-item>
      
      <el-form-item label="格式">
        <el-select
          v-model="filters.format"
          placeholder="全部"
          style="width: 100px"
          @change="emitChange"
        >
          <el-option label="全部" value="" />
          <el-option label="JSON" value="json" />
          <el-option label="HEX" value="hex" />
          <el-option label="纯文本" value="text" />
        </el-select>
      </el-form-item>
      
      <el-form-item label="时间范围">
        <el-date-picker
          v-model="filters.timeRange"
          type="datetimerange"
          range-separator="-"
          start-placeholder="开始时间"
          end-placeholder="结束时间"
          value-format="YYYY-MM-DD HH:mm:ss"
          style="width: 340px"
          @change="emitChange"
        />
      </el-form-item>
      
      <el-form-item>
        <el-button @click="resetFilters">重置</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script setup lang="ts">
import { reactive } from 'vue'

export interface MessageFilters {
  topic: string
  direction: '' | 'publish' | 'receive'
  format: '' | 'json' | 'hex' | 'text'
  timeRange: [string, string] | null
}

const emit = defineEmits<{
  change: [filters: MessageFilters]
}>()

const filters = reactive<MessageFilters>({
  topic: '',
  direction: '',
  format: '',
  timeRange: null,
})

function emitChange() {
  emit('change', { ...filters })
}

function resetFilters() {
  filters.topic = ''
  filters.direction = ''
  filters.format = ''
  filters.timeRange = null
  emitChange()
}
</script>

<style scoped>
.message-filter {
  padding: 12px 16px;
  background-color: var(--el-fill-color-light);
  border-radius: 8px;
  margin-bottom: 16px;
}

.message-filter :deep(.el-form-item) {
  margin-bottom: 0;
  margin-right: 16px;
}

.message-filter :deep(.el-form-item__label) {
  font-size: 12px;
}
</style>
```

---

## 测试要点

1. **消息列表测试**
   - 消息正确按时间排序显示
   - 发布/接收消息样式区分
   - 消息数量过多时的性能

2. **格式化显示测试**
   - JSON 格式化和语法高亮
   - HEX 显示和 ASCII 对照
   - 大消息的截断显示

3. **过滤搜索测试**
   - 主题过滤正确工作
   - 关键词搜索准确
   - 时间范围过滤

4. **交互功能测试**
   - 消息详情弹窗
   - 复制功能
   - 重新发布功能

---

## 完成标准

- [ ] 消息列表实时更新
- [ ] 三种格式正确显示
- [ ] 过滤搜索功能正常
- [ ] 消息详情交互完善
- [ ] 性能满足要求（>1000条消息流畅）
