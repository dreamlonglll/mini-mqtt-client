# 阶段三：MQTT 连接功能

## 目标概述

实现 MQTT 客户端的连接管理功能，包括连接/断开、状态同步和错误处理。

## 前置条件

- 阶段二已完成
- Server 配置可以正常 CRUD
- rumqttc 依赖已安装

## 任务清单

### 3.1 创建 MQTT 客户端管理器 (Rust)

#### 任务描述
封装 rumqttc，实现多连接管理

#### 新增文件
- `src-tauri/src/mqtt/mod.rs`
- `src-tauri/src/mqtt/client.rs`

#### 代码实现

**src-tauri/src/mqtt/mod.rs**
```rust
pub mod client;

pub use client::MqttManager;
```

**src-tauri/src/mqtt/client.rs**
```rust
use parking_lot::RwLock;
use rumqttc::{AsyncClient, Event, EventLoop, MqttOptions, Packet, QoS};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;
use tauri::{AppHandle, Emitter, Manager};
use tokio::sync::mpsc;

use crate::db::models::MqttServer;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionState {
    pub server_id: i64,
    pub status: String, // "disconnected", "connecting", "connected", "error"
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReceivedMessage {
    pub server_id: i64,
    pub topic: String,
    pub payload: Vec<u8>,
    pub qos: u8,
    pub retain: bool,
    pub timestamp: String,
}

struct ClientHandle {
    client: AsyncClient,
    shutdown_tx: mpsc::Sender<()>,
}

pub struct MqttManager {
    clients: Arc<RwLock<HashMap<i64, ClientHandle>>>,
    app_handle: AppHandle,
}

impl MqttManager {
    pub fn new(app_handle: AppHandle) -> Self {
        Self {
            clients: Arc::new(RwLock::new(HashMap::new())),
            app_handle,
        }
    }

    pub async fn connect(&self, server: MqttServer) -> Result<(), String> {
        let server_id = server.id.ok_or("Server ID is required")?;

        // 如果已连接，先断开
        self.disconnect(server_id).await?;

        // 发送连接中状态
        self.emit_state(server_id, "connecting", None);

        // 构建 MQTT 配置
        let client_id = server.client_id.unwrap_or_else(|| {
            format!("mqtt_client_{}", uuid::Uuid::new_v4())
        });

        let mut options = MqttOptions::new(client_id, &server.host, server.port as u16);
        options.set_keep_alive(Duration::from_secs(server.keep_alive as u64));
        options.set_clean_session(server.clean_session);

        if let (Some(username), Some(password)) = (server.username.as_ref(), server.password.as_ref()) {
            if !username.is_empty() {
                options.set_credentials(username, password);
            }
        }

        // 创建客户端
        let (client, eventloop) = AsyncClient::new(options, 100);

        // 创建停止信号
        let (shutdown_tx, shutdown_rx) = mpsc::channel::<()>(1);

        // 保存客户端句柄
        {
            let mut clients = self.clients.write();
            clients.insert(server_id, ClientHandle {
                client: client.clone(),
                shutdown_tx,
            });
        }

        // 启动事件循环
        let app_handle = self.app_handle.clone();
        let clients = self.clients.clone();
        
        tokio::spawn(async move {
            Self::run_eventloop(server_id, eventloop, shutdown_rx, app_handle, clients).await;
        });

        Ok(())
    }

    async fn run_eventloop(
        server_id: i64,
        mut eventloop: EventLoop,
        mut shutdown_rx: mpsc::Receiver<()>,
        app_handle: AppHandle,
        clients: Arc<RwLock<HashMap<i64, ClientHandle>>>,
    ) {
        let mut connected = false;

        loop {
            tokio::select! {
                _ = shutdown_rx.recv() => {
                    Self::emit_state_static(&app_handle, server_id, "disconnected", None);
                    break;
                }
                event = eventloop.poll() => {
                    match event {
                        Ok(Event::Incoming(Packet::ConnAck(ack))) => {
                            if ack.code == rumqttc::ConnectReturnCode::Success {
                                connected = true;
                                Self::emit_state_static(&app_handle, server_id, "connected", None);
                            } else {
                                Self::emit_state_static(
                                    &app_handle,
                                    server_id,
                                    "error",
                                    Some(format!("Connection refused: {:?}", ack.code)),
                                );
                                break;
                            }
                        }
                        Ok(Event::Incoming(Packet::Publish(publish))) => {
                            let msg = ReceivedMessage {
                                server_id,
                                topic: publish.topic.clone(),
                                payload: publish.payload.to_vec(),
                                qos: publish.qos as u8,
                                retain: publish.retain,
                                timestamp: chrono::Utc::now().to_rfc3339(),
                            };
                            let _ = app_handle.emit("mqtt-message", msg);
                        }
                        Ok(Event::Incoming(Packet::SubAck(_))) => {
                            // 订阅成功
                        }
                        Ok(Event::Incoming(Packet::PingResp)) => {
                            // Ping 响应
                        }
                        Err(e) => {
                            if connected {
                                Self::emit_state_static(
                                    &app_handle,
                                    server_id,
                                    "error",
                                    Some(format!("Connection error: {}", e)),
                                );
                            } else {
                                Self::emit_state_static(
                                    &app_handle,
                                    server_id,
                                    "error",
                                    Some(format!("Failed to connect: {}", e)),
                                );
                            }
                            break;
                        }
                        _ => {}
                    }
                }
            }
        }

        // 清理客户端
        let mut clients = clients.write();
        clients.remove(&server_id);
    }

    pub async fn disconnect(&self, server_id: i64) -> Result<(), String> {
        let handle = {
            let clients = self.clients.read();
            clients.get(&server_id).map(|h| h.shutdown_tx.clone())
        };

        if let Some(tx) = handle {
            let _ = tx.send(()).await;
        }

        Ok(())
    }

    pub async fn publish(
        &self,
        server_id: i64,
        topic: String,
        payload: Vec<u8>,
        qos: u8,
        retain: bool,
    ) -> Result<(), String> {
        let client = {
            let clients = self.clients.read();
            clients.get(&server_id).map(|h| h.client.clone())
        };

        let client = client.ok_or("Not connected")?;

        let qos = match qos {
            0 => QoS::AtMostOnce,
            1 => QoS::AtLeastOnce,
            2 => QoS::ExactlyOnce,
            _ => return Err("Invalid QoS".to_string()),
        };

        client
            .publish(topic, qos, retain, payload)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn subscribe(&self, server_id: i64, topic: String, qos: u8) -> Result<(), String> {
        let client = {
            let clients = self.clients.read();
            clients.get(&server_id).map(|h| h.client.clone())
        };

        let client = client.ok_or("Not connected")?;

        let qos = match qos {
            0 => QoS::AtMostOnce,
            1 => QoS::AtLeastOnce,
            2 => QoS::ExactlyOnce,
            _ => return Err("Invalid QoS".to_string()),
        };

        client
            .subscribe(topic, qos)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn unsubscribe(&self, server_id: i64, topic: String) -> Result<(), String> {
        let client = {
            let clients = self.clients.read();
            clients.get(&server_id).map(|h| h.client.clone())
        };

        let client = client.ok_or("Not connected")?;

        client
            .unsubscribe(topic)
            .await
            .map_err(|e| e.to_string())
    }

    fn emit_state(&self, server_id: i64, status: &str, error: Option<String>) {
        Self::emit_state_static(&self.app_handle, server_id, status, error);
    }

    fn emit_state_static(app_handle: &AppHandle, server_id: i64, status: &str, error: Option<String>) {
        let state = ConnectionState {
            server_id,
            status: status.to_string(),
            error,
        };
        let _ = app_handle.emit("mqtt-connection-state", state);
    }

    pub fn is_connected(&self, server_id: i64) -> bool {
        let clients = self.clients.read();
        clients.contains_key(&server_id)
    }
}
```

#### 验收标准
- 编译成功
- 支持多连接管理

---

### 3.2 创建 MQTT 命令

#### 任务描述
创建 Tauri 命令以暴露 MQTT 功能

#### 新增文件
`src-tauri/src/commands/mqtt.rs`

#### 代码实现
```rust
use crate::db::Storage;
use crate::mqtt::MqttManager;
use tauri::State;

#[tauri::command]
pub async fn mqtt_connect(
    storage: State<'_, Storage>,
    mqtt: State<'_, MqttManager>,
    server_id: i64,
) -> Result<(), String> {
    // 从存储获取 server 配置
    let server = storage
        .get_server(server_id)
        .ok_or("Server not found")?;

    mqtt.connect(server).await
}

#[tauri::command]
pub async fn mqtt_disconnect(
    mqtt: State<'_, MqttManager>,
    server_id: i64,
) -> Result<(), String> {
    mqtt.disconnect(server_id).await
}

#[tauri::command]
pub async fn mqtt_publish(
    mqtt: State<'_, MqttManager>,
    server_id: i64,
    topic: String,
    payload: Vec<u8>,
    qos: u8,
    retain: bool,
) -> Result<(), String> {
    mqtt.publish(server_id, topic, payload, qos, retain).await
}

#[tauri::command]
pub async fn mqtt_subscribe(
    mqtt: State<'_, MqttManager>,
    server_id: i64,
    topic: String,
    qos: u8,
) -> Result<(), String> {
    mqtt.subscribe(server_id, topic, qos).await
}

#[tauri::command]
pub async fn mqtt_unsubscribe(
    mqtt: State<'_, MqttManager>,
    server_id: i64,
    topic: String,
) -> Result<(), String> {
    mqtt.unsubscribe(server_id, topic).await
}

#[tauri::command]
pub fn mqtt_is_connected(
    mqtt: State<'_, MqttManager>,
    server_id: i64,
) -> bool {
    mqtt.is_connected(server_id)
}
```

#### 修改文件
- `src-tauri/src/commands/mod.rs` - 添加 mqtt 模块
- `src-tauri/src/lib.rs` - 注册命令和 MqttManager

#### 验收标准
- 命令注册成功
- 可通过 invoke 调用

---

### 3.3 创建 MQTT Store

#### 任务描述
创建管理 MQTT 连接状态的 Store

#### 新增文件
`src/stores/mqtt.ts`

#### 代码实现
```typescript
import { defineStore } from "pinia";
import { ref } from "vue";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import type { ConnectionStatus, MqttMessage } from "@/types/mqtt";

interface ConnectionState {
  server_id: number;
  status: ConnectionStatus;
  error?: string;
}

interface ReceivedMessage {
  server_id: number;
  topic: string;
  payload: number[];
  qos: number;
  retain: boolean;
  timestamp: string;
}

export const useMqttStore = defineStore("mqtt", () => {
  // 连接状态
  const connectionStates = ref<Map<number, { status: ConnectionStatus; error?: string }>>(
    new Map()
  );

  // 接收到的消息
  const messages = ref<MqttMessage[]>([]);

  // 订阅列表（按 server_id 分组）
  const subscriptions = ref<Map<number, Set<string>>>(new Map());

  // 初始化事件监听
  const initListeners = async () => {
    // 监听连接状态变化
    await listen<ConnectionState>("mqtt-connection-state", (event) => {
      const { server_id, status, error } = event.payload;
      connectionStates.value.set(server_id, { status: status as ConnectionStatus, error });
    });

    // 监听接收消息
    await listen<ReceivedMessage>("mqtt-message", (event) => {
      const msg = event.payload;
      messages.value.unshift({
        server_id: msg.server_id,
        direction: "receive",
        topic: msg.topic,
        payload: new Uint8Array(msg.payload),
        qos: msg.qos as 0 | 1 | 2,
        retain: msg.retain,
        timestamp: msg.timestamp,
      });

      // 限制消息数量
      if (messages.value.length > 1000) {
        messages.value = messages.value.slice(0, 1000);
      }
    });
  };

  // 连接
  const connect = async (serverId: number) => {
    await invoke("mqtt_connect", { serverId });
  };

  // 断开连接
  const disconnect = async (serverId: number) => {
    await invoke("mqtt_disconnect", { serverId });
  };

  // 发布消息
  const publish = async (
    serverId: number,
    topic: string,
    payload: string | Uint8Array,
    qos: 0 | 1 | 2 = 0,
    retain: boolean = false
  ) => {
    const payloadBytes = typeof payload === "string" 
      ? Array.from(new TextEncoder().encode(payload))
      : Array.from(payload);
    
    await invoke("mqtt_publish", {
      serverId,
      topic,
      payload: payloadBytes,
      qos,
      retain,
    });

    // 添加到消息列表
    messages.value.unshift({
      server_id: serverId,
      direction: "publish",
      topic,
      payload: typeof payload === "string" ? new TextEncoder().encode(payload) : payload,
      qos,
      retain,
      timestamp: new Date().toISOString(),
    });
  };

  // 订阅
  const subscribe = async (serverId: number, topic: string, qos: 0 | 1 | 2 = 0) => {
    await invoke("mqtt_subscribe", { serverId, topic, qos });
    
    if (!subscriptions.value.has(serverId)) {
      subscriptions.value.set(serverId, new Set());
    }
    subscriptions.value.get(serverId)!.add(topic);
  };

  // 取消订阅
  const unsubscribe = async (serverId: number, topic: string) => {
    await invoke("mqtt_unsubscribe", { serverId, topic });
    subscriptions.value.get(serverId)?.delete(topic);
  };

  // 获取连接状态
  const getConnectionStatus = (serverId: number): ConnectionStatus => {
    return connectionStates.value.get(serverId)?.status || "disconnected";
  };

  // 获取连接错误
  const getConnectionError = (serverId: number): string | undefined => {
    return connectionStates.value.get(serverId)?.error;
  };

  // 获取某个 server 的消息
  const getServerMessages = (serverId: number) => {
    return messages.value.filter((m) => m.server_id === serverId);
  };

  // 清空消息
  const clearMessages = (serverId?: number) => {
    if (serverId) {
      messages.value = messages.value.filter((m) => m.server_id !== serverId);
    } else {
      messages.value = [];
    }
  };

  return {
    connectionStates,
    messages,
    subscriptions,
    initListeners,
    connect,
    disconnect,
    publish,
    subscribe,
    unsubscribe,
    getConnectionStatus,
    getConnectionError,
    getServerMessages,
    clearMessages,
  };
});
```

#### 验收标准
- Store 功能完整
- 事件监听正常工作

---

### 3.4 创建连接控制组件

#### 任务描述
创建连接/断开控制的 UI 组件

#### 新增文件
`src/components/mqtt/ConnectionControl.vue`

#### 代码实现
```vue
<template>
  <div class="connection-control">
    <div class="status-info">
      <span class="status-dot" :class="statusClass" />
      <span class="status-text">{{ statusText }}</span>
    </div>
    
    <div class="control-buttons">
      <el-button
        v-if="status === 'disconnected' || status === 'error'"
        type="primary"
        :loading="status === 'connecting'"
        @click="handleConnect"
      >
        连接
      </el-button>
      <el-button
        v-else
        type="danger"
        :loading="status === 'connecting'"
        @click="handleDisconnect"
      >
        断开
      </el-button>
    </div>

    <el-alert
      v-if="error"
      :title="error"
      type="error"
      show-icon
      closable
      class="error-alert"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from "vue";
import { ElMessage } from "element-plus";
import { useMqttStore } from "@/stores/mqtt";

const props = defineProps<{
  serverId: number;
}>();

const mqttStore = useMqttStore();

const status = computed(() => mqttStore.getConnectionStatus(props.serverId));
const error = computed(() => mqttStore.getConnectionError(props.serverId));

const statusClass = computed(() => ({
  connected: status.value === "connected",
  connecting: status.value === "connecting",
  error: status.value === "error",
  disconnected: status.value === "disconnected",
}));

const statusText = computed(() => {
  switch (status.value) {
    case "connected":
      return "已连接";
    case "connecting":
      return "连接中...";
    case "error":
      return "连接错误";
    default:
      return "未连接";
  }
});

const handleConnect = async () => {
  try {
    await mqttStore.connect(props.serverId);
  } catch (e) {
    ElMessage.error(`连接失败: ${e}`);
  }
};

const handleDisconnect = async () => {
  try {
    await mqttStore.disconnect(props.serverId);
  } catch (e) {
    ElMessage.error(`断开失败: ${e}`);
  }
};
</script>

<style scoped lang="scss">
.connection-control {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}

.status-info {
  display: flex;
  align-items: center;
  gap: 8px;
}

.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: var(--el-color-info-light-5);

  &.connected {
    background-color: var(--el-color-success);
  }

  &.connecting {
    background-color: var(--el-color-warning);
    animation: pulse 1.5s infinite;
  }

  &.error {
    background-color: var(--el-color-danger);
  }
}

.status-text {
  font-size: 14px;
  color: var(--app-text-color);
}

.error-alert {
  width: 100%;
  margin-top: 8px;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}
</style>
```

#### 验收标准
- 状态显示正确
- 连接/断开功能正常

---

### 3.5 初始化 MQTT 事件监听

#### 任务描述
在应用启动时初始化事件监听

#### 修改文件
`src/App.vue`

```vue
<script setup lang="ts">
import { onMounted } from "vue";
import { useAppStore } from "@/stores/app";
import { useMqttStore } from "@/stores/mqtt";
import AppLayout from "@/components/layout/AppLayout.vue";

const appStore = useAppStore();
const mqttStore = useMqttStore();

onMounted(() => {
  appStore.initTheme();
  mqttStore.initListeners();
});
</script>
```

#### 验收标准
- 事件监听在启动时初始化
- 状态变化可以正确接收

---

## 完成检查清单

- [ ] MqttManager 实现完成
- [ ] MQTT 命令创建完成
- [ ] MQTT Store 创建完成
- [ ] 连接控制组件开发完成
- [ ] 事件监听初始化完成
- [ ] 连接/断开功能测试通过
- [ ] 状态同步测试通过

## 预期产出

1. 完整的 MQTT 连接管理
2. 连接状态实时同步
3. 错误处理和显示
4. 支持多个同时连接
