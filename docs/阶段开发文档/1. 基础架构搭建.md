# 阶段一：基础架构搭建

## 目标概述

搭建项目的基础架构，包括前端 UI 框架配置、状态管理、主题系统，以及后端数据存储和 MQTT 库的集成。

## 任务清单

### 1.1 前端依赖安装

#### 任务描述
安装 Element Plus、Pinia 及相关依赖

#### 执行命令
```bash
npm install element-plus @element-plus/icons-vue pinia
npm install -D unplugin-auto-import unplugin-vue-components sass
```

#### 验收标准
- package.json 中包含所有依赖
- npm install 无报错

---

### 1.2 配置 Element Plus 自动导入

#### 任务描述
配置 Vite 插件实现 Element Plus 组件和 API 的自动导入

#### 修改文件
`vite.config.ts`

#### 代码实现
```typescript
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import AutoImport from "unplugin-auto-import/vite";
import Components from "unplugin-vue-components/vite";
import { ElementPlusResolver } from "unplugin-vue-components/resolvers";

const host = process.env.TAURI_DEV_HOST;

export default defineConfig({
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
      imports: ["vue", "pinia"],
      dts: "src/auto-imports.d.ts",
    }),
    Components({
      resolvers: [ElementPlusResolver()],
      dts: "src/components.d.ts",
    }),
  ],
  clearScreen: false,
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host ? { protocol: "ws", host, port: 1421 } : undefined,
    watch: { ignored: ["**/src-tauri/**"] },
  },
});
```

#### 验收标准
- 组件可以直接使用无需手动 import
- 生成 auto-imports.d.ts 和 components.d.ts

---

### 1.3 配置 Pinia 状态管理

#### 任务描述
初始化 Pinia 并创建基础 Store 结构

#### 新增文件
- `src/stores/index.ts` - Pinia 实例
- `src/stores/app.ts` - 应用全局状态（主题等）

#### 代码实现

**src/stores/index.ts**
```typescript
import { createPinia } from "pinia";

const pinia = createPinia();

export default pinia;
```

**src/stores/app.ts**
```typescript
import { defineStore } from "pinia";
import { ref } from "vue";

export const useAppStore = defineStore("app", () => {
  // 主题：light / dark
  const theme = ref<"light" | "dark">("light");

  // 切换主题
  const toggleTheme = () => {
    theme.value = theme.value === "light" ? "dark" : "light";
    applyTheme();
  };

  // 设置主题
  const setTheme = (newTheme: "light" | "dark") => {
    theme.value = newTheme;
    applyTheme();
  };

  // 应用主题到 DOM
  const applyTheme = () => {
    if (theme.value === "dark") {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  };

  // 初始化主题（从系统偏好或本地存储）
  const initTheme = () => {
    const stored = localStorage.getItem("theme");
    if (stored === "light" || stored === "dark") {
      theme.value = stored;
    } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme.value = "dark";
    }
    applyTheme();
  };

  return {
    theme,
    toggleTheme,
    setTheme,
    initTheme,
  };
});
```

#### 修改文件
`src/main.ts` - 注册 Pinia

```typescript
import { createApp } from "vue";
import App from "./App.vue";
import pinia from "./stores";
import "element-plus/theme-chalk/dark/css-vars.css";

const app = createApp(App);
app.use(pinia);
app.mount("#app");
```

#### 验收标准
- Pinia 正常工作
- useAppStore 可以正常使用

---

### 1.4 配置深浅色主题切换

#### 任务描述
实现 Element Plus 深浅色主题切换

#### 新增文件
- `src/assets/styles/index.scss` - 全局样式
- `src/assets/styles/variables.scss` - CSS 变量

#### 代码实现

**src/assets/styles/variables.scss**
```scss
:root {
  --app-bg-color: #f5f7fa;
  --app-text-color: #303133;
  --app-border-color: #dcdfe6;
  --sidebar-bg: #ffffff;
  --sidebar-width: 280px;
}

html.dark {
  --app-bg-color: #141414;
  --app-text-color: #e5eaf3;
  --app-border-color: #414243;
  --sidebar-bg: #1d1d1d;
}
```

**src/assets/styles/index.scss**
```scss
@use "./variables.scss";

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body,
#app {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
    Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  background-color: var(--app-bg-color);
  color: var(--app-text-color);
  transition: background-color 0.3s, color 0.3s;
}

// 滚动条样式
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-thumb {
  background-color: var(--el-border-color);
  border-radius: 3px;
}

::-webkit-scrollbar-track {
  background-color: transparent;
}
```

#### 修改文件
`src/main.ts` - 引入样式

```typescript
import { createApp } from "vue";
import App from "./App.vue";
import pinia from "./stores";
import "element-plus/theme-chalk/dark/css-vars.css";
import "./assets/styles/index.scss";

const app = createApp(App);
app.use(pinia);
app.mount("#app");
```

#### 验收标准
- 深色/浅色主题可切换
- 主题状态持久化到 localStorage

---

### 1.5 创建基础布局组件

#### 任务描述
创建应用的主布局结构

#### 新增文件
- `src/components/layout/AppLayout.vue` - 主布局
- `src/components/layout/Sidebar.vue` - 左侧边栏
- `src/components/layout/Header.vue` - 顶部栏

#### 验收标准
- 布局正常显示
- 主题切换按钮工作正常

---

### 1.6 配置路径别名

#### 任务描述
配置 TypeScript 和 Vite 的路径别名

#### 修改文件
- `vite.config.ts`
- `tsconfig.json`

#### 代码实现

**vite.config.ts** 添加:
```typescript
import { resolve } from "path";

export default defineConfig({
  // ... 其他配置
  resolve: {
    alias: {
      "@": resolve(__dirname, "src"),
    },
  },
});
```

**tsconfig.json** 添加:
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

#### 验收标准
- `@/` 别名在 import 中正常工作
- TypeScript 类型提示正常

---

### 1.7 Rust 后端依赖安装

#### 任务描述
添加 YAML 存储、MQTT 和其他必要的 Rust 依赖

#### 修改文件
`src-tauri/Cargo.toml`

#### 代码实现
```toml
[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_yaml = "0.9"
rumqttc = "0.24"
tokio = { version = "1", features = ["full"] }
thiserror = "2.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.11", features = ["v4"] }
parking_lot = "0.12"
hex = "0.4"
```

#### 验收标准
- `cargo build` 编译成功
- 所有依赖正确解析

---

### 1.8 数据存储初始化模块

#### 任务描述
创建 YAML 文件存储初始化和数据模型

#### 新增文件
- `src-tauri/src/db/mod.rs`
- `src-tauri/src/db/models.rs`

#### 代码实现

**src-tauri/src/db/mod.rs**
```rust
pub mod models;

use models::{MessageHistory, MqttServer, Subscription};
use parking_lot::RwLock;
use std::fs;
use std::path::PathBuf;
use tauri::AppHandle;
use tauri::Manager;

#[derive(Debug, serde::Serialize, serde::Deserialize, Default)]
pub struct AppData {
    pub servers: Vec<MqttServer>,
    pub subscriptions: Vec<Subscription>,
    pub messages: Vec<MessageHistory>,
    #[serde(default)]
    next_server_id: i64,
    #[serde(default)]
    next_subscription_id: i64,
    #[serde(default)]
    next_message_id: i64,
}

pub struct Storage {
    data: RwLock<AppData>,
    file_path: PathBuf,
}

impl Storage {
    pub fn new(app_handle: &AppHandle) -> Result<Self, String> {
        let app_dir = app_handle
            .path()
            .app_data_dir()
            .map_err(|e| e.to_string())?;

        fs::create_dir_all(&app_dir).map_err(|e| e.to_string())?;

        let file_path = app_dir.join("data.yaml");

        let data = if file_path.exists() {
            let content = fs::read_to_string(&file_path).map_err(|e| e.to_string())?;
            serde_yaml::from_str(&content).unwrap_or_default()
        } else {
            AppData::default()
        };

        Ok(Self {
            data: RwLock::new(data),
            file_path,
        })
    }

    fn save(&self) -> Result<(), String> {
        let data = self.data.read();
        let content = serde_yaml::to_string(&*data).map_err(|e| e.to_string())?;
        fs::write(&self.file_path, content).map_err(|e| e.to_string())
    }

    // ... CRUD 操作方法
}
```

**src-tauri/src/db/models.rs**
```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MqttServer {
    pub id: Option<i64>,
    pub name: String,
    pub host: String,
    pub port: i32,
    pub protocol_version: String,
    pub username: Option<String>,
    pub password: Option<String>,
    pub client_id: Option<String>,
    pub keep_alive: i32,
    pub clean_session: bool,
    pub use_tls: bool,
    pub ca_cert: Option<String>,
    pub client_cert: Option<String>,
    pub client_key: Option<String>,
    pub created_at: Option<String>,
    pub updated_at: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Subscription {
    pub id: Option<i64>,
    pub server_id: i64,
    pub topic: String,
    pub qos: i32,
    pub is_active: bool,
    pub created_at: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageHistory {
    pub id: Option<i64>,
    pub server_id: i64,
    pub direction: String,
    pub topic: String,
    pub payload: Option<String>,
    pub payload_format: Option<String>,
    pub qos: i32,
    pub retain: bool,
    pub created_at: Option<String>,
}
```

#### 修改文件
`src-tauri/src/lib.rs` - 初始化存储

```rust
mod db;

use db::Storage;
use tauri::Manager;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .setup(|app| {
            let storage = Storage::new(&app.handle())?;
            app.manage(storage);
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 验收标准
- 应用启动时自动创建数据目录
- 数据正确保存到 YAML 文件

---

## 完成检查清单

- [ ] Element Plus 安装并配置自动导入
- [ ] Pinia 状态管理配置完成
- [ ] 深浅色主题切换正常工作
- [ ] 基础布局组件创建完成
- [ ] 路径别名配置完成
- [ ] Rust 依赖安装成功
- [ ] 数据存储模块初始化完成
- [ ] 项目可以正常启动 (`npm run tauri dev`)

## 预期产出

1. 完整的前端基础架构
2. 可切换的深浅色主题
3. 基础布局框架
4. YAML 文件存储初始化
5. 项目可以正常编译运行
