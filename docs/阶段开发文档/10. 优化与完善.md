七：优化与完善

## 目标

完成应用的优化工作，包括性能优化、用户体验提升、错误处理完善等。

## 任务清单

- [ ] 性能优化
- [ ] 错误处理完善
- [ ] 用户体验优化
- [ ] 国际化支持（可选）
- [ ] 应用打包与发布

---

## 1. 性能优化

### 1.1 虚拟列表优化

对于大量消息的展示，使用虚拟列表提升性能。

### 文件：`src/components/message/VirtualMessageList.vue`

```vue
<template>
  <div ref="containerRef" class="virtual-list-container" @scroll="handleScroll">
    <div class="virtual-list-phantom" :style="{ height: totalHeight + 'px' }"></div>
    <div class="virtual-list-content" :style="{ transform: `translateY(${offset}px)` }">
      <div
        v-for="item in visibleItems"
        :key="item.id"
        class="virtual-list-item"
        :style="{ height: itemHeight + 'px' }"
      >
        <MessageItem :message="item" @click="$emit('select', item)" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import type { MqttMessage } from '@/stores/message'
import MessageItem from './MessageItem.vue'

const props = withDefaults(defineProps<{
  messages: MqttMessage[]
  itemHeight?: number
  bufferSize?: number
}>(), {
  itemHeight: 80,
  bufferSize: 5
})

defineEmits<{
  select: [message: MqttMessage]
}>()

const containerRef = ref<HTMLElement>()
const scrollTop = ref(0)
const containerHeight = ref(0)

const totalHeight = computed(() => props.messages.length * props.itemHeight)

const startIndex = computed(() => {
  const start = Math.floor(scrollTop.value / props.itemHeight) - props.bufferSize
  return Math.max(0, start)
})

const endIndex = computed(() => {
  const visibleCount = Math.ceil(containerHeight.value / props.itemHeight)
  const end = startIndex.value + visibleCount + props.bufferSize * 2
  return Math.min(props.messages.length, end)
})

const visibleItems = computed(() => {
  return props.messages.slice(startIndex.value, endIndex.value)
})

const offset = computed(() => startIndex.value * props.itemHeight)

function handleScroll() {
  if (containerRef.value) {
    scrollTop.value = containerRef.value.scrollTop
  }
}

function updateContainerHeight() {
  if (containerRef.value) {
    containerHeight.value = containerRef.value.clientHeight
  }
}

// 自动滚动到底部
function scrollToBottom() {
  if (containerRef.value) {
    containerRef.value.scrollTop = totalHeight.value
  }
}

// 监听新消息，自动滚动
watch(() => props.messages.length, (newLen, oldLen) => {
  if (newLen > oldLen) {
    // 如果已经在底部附近，则自动滚动
    const isNearBottom = containerRef.value && 
      (containerRef.value.scrollHeight - containerRef.value.scrollTop - containerRef.value.clientHeight < 100)
    
    if (isNearBottom) {
      setTimeout(scrollToBottom, 0)
    }
  }
})

onMounted(() => {
  updateContainerHeight()
  window.addEventListener('resize', updateContainerHeight)
})

onUnmounted(() => {
  window.removeEventListener('resize', updateContainerHeight)
})

defineExpose({
  scrollToBottom
})
</script>

<style scoped>
.virtual-list-container {
  height: 100%;
  overflow-y: auto;
  position: relative;
}

.virtual-list-phantom {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.virtual-list-content {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.virtual-list-item {
  box-sizing: border-box;
}
</style>
```

### 1.2 消息防抖与节流

### 文件：`src/utils/debounce.ts`

```typescript
export function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout> | null = null
  
  return function (this: any, ...args: Parameters<T>) {
    if (timeoutId) {
      clearTimeout(timeoutId)
    }
    
    timeoutId = setTimeout(() => {
      fn.apply(this, args)
      timeoutId = null
    }, delay)
  }
}

export function throttle<T extends (...args: any[]) => any>(
  fn: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle = false
  let lastArgs: Parameters<T> | null = null
  
  return function (this: any, ...args: Parameters<T>) {
    if (!inThrottle) {
      fn.apply(this, args)
      inThrottle = true
      
      setTimeout(() => {
        inThrottle = false
        if (lastArgs) {
          fn.apply(this, lastArgs)
          lastArgs = null
        }
      }, limit)
    } else {
      lastArgs = args
    }
  }
}
```

### 1.3 消息缓存策略

### 文件：`src/utils/messageCache.ts`

```typescript
interface CacheOptions {
  maxSize: number
  maxAge: number // 毫秒
}

interface CacheItem<T> {
  value: T
  timestamp: number
}

export class MessageCache<T> {
  private cache: Map<string, CacheItem<T>> = new Map()
  private options: CacheOptions

  constructor(options: Partial<CacheOptions> = {}) {
    this.options = {
      maxSize: options.maxSize ?? 1000,
      maxAge: options.maxAge ?? 5 * 60 * 1000 // 5分钟
    }
  }

  get(key: string): T | undefined {
    const item = this.cache.get(key)
    
    if (!item) {
      return undefined
    }
    
    // 检查是否过期
    if (Date.now() - item.timestamp > this.options.maxAge) {
      this.cache.delete(key)
      return undefined
    }
    
    return item.value
  }

  set(key: string, value: T): void {
    // 检查容量
    if (this.cache.size >= this.options.maxSize) {
      // 删除最旧的项
      const oldestKey = this.cache.keys().next().value
      if (oldestKey) {
        this.cache.delete(oldestKey)
      }
    }
    
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    })
  }

  delete(key: string): boolean {
    return this.cache.delete(key)
  }

  clear(): void {
    this.cache.clear()
  }

  // 清理过期项
  cleanup(): void {
    const now = Date.now()
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.options.maxAge) {
        this.cache.delete(key)
      }
    }
  }

  get size(): number {
    return this.cache.size
  }
}

// 格式化后的消息缓存
export const formattedMessageCache = new MessageCache<string>({
  maxSize: 500,
  maxAge: 10 * 60 * 1000 // 10分钟
})
```

---

## 2. 错误处理完善

### 2.1 全局错误处理

### 文件：`src/utils/errorHandler.ts`

```typescript
import { ElNotification } from 'element-plus'

export enum ErrorType {
  NETWORK = 'network',
  MQTT = 'mqtt',
  DATABASE = 'database',
  VALIDATION = 'validation',
  UNKNOWN = 'unknown'
}

export interface AppError {
  type: ErrorType
  message: string
  details?: any
  timestamp: Date
}

class ErrorHandler {
  private errors: AppError[] = []
  private maxErrors = 100

  handle(error: unknown, type: ErrorType = ErrorType.UNKNOWN): AppError {
    const appError = this.createAppError(error, type)
    this.logError(appError)
    this.storeError(appError)
    this.notifyUser(appError)
    return appError
  }

  private createAppError(error: unknown, type: ErrorType): AppError {
    let message = '发生未知错误'
    let details: any

    if (error instanceof Error) {
      message = error.message
      details = {
        name: error.name,
        stack: error.stack
      }
    } else if (typeof error === 'string') {
      message = error
    } else if (error && typeof error === 'object') {
      message = (error as any).message || JSON.stringify(error)
      details = error
    }

    return {
      type,
      message,
      details,
      timestamp: new Date()
    }
  }

  private logError(error: AppError): void {
    console.error(`[${error.type.toUpperCase()}] ${error.message}`, error.details)
  }

  private storeError(error: AppError): void {
    this.errors.unshift(error)
    if (this.errors.length > this.maxErrors) {
      this.errors = this.errors.slice(0, this.maxErrors)
    }
  }

  private notifyUser(error: AppError): void {
    const titles: Record<ErrorType, string> = {
      [ErrorType.NETWORK]: '网络错误',
      [ErrorType.MQTT]: 'MQTT错误',
      [ErrorType.DATABASE]: '数据库错误',
      [ErrorType.VALIDATION]: '验证错误',
      [ErrorType.UNKNOWN]: '错误'
    }

    ElNotification({
      title: titles[error.type],
      message: error.message,
      type: 'error',
      duration: 5000
    })
  }

  getErrors(): AppError[] {
    return [...this.errors]
  }

  clearErrors(): void {
    this.errors = []
  }
}

export const errorHandler = new ErrorHandler()

// 全局错误捕获
export function setupGlobalErrorHandler(): void {
  window.addEventListener('error', (event) => {
    errorHandler.handle(event.error, ErrorType.UNKNOWN)
  })

  window.addEventListener('unhandledrejection', (event) => {
    errorHandler.handle(event.reason, ErrorType.UNKNOWN)
  })
}
```

### 2.2 MQTT错误处理增强

### 文件：`src/utils/mqttErrorHandler.ts`

```typescript
import { errorHandler, ErrorType } from './errorHandler'

export interface MqttErrorInfo {
  code: string
  message: string
  suggestion: string
}

const mqttErrorMap: Record<string, MqttErrorInfo> = {
  'connection_refused': {
    code: 'CONNECTION_REFUSED',
    message: '连接被拒绝',
    suggestion: '请检查服务器地址和端口是否正确'
  },
  'connection_timeout': {
    code: 'CONNECTION_TIMEOUT',
    message: '连接超时',
    suggestion: '请检查网络连接或服务器是否可用'
  },
  'auth_failed': {
    code: 'AUTH_FAILED',
    message: '认证失败',
    suggestion: '请检查用户名和密码是否正确'
  },
  'not_authorized': {
    code: 'NOT_AUTHORIZED',
    message: '未授权',
    suggestion: '当前用户没有该操作权限'
  },
  'topic_invalid': {
    code: 'TOPIC_INVALID',
    message: '主题格式无效',
    suggestion: '请检查主题格式是否符合MQTT规范'
  },
  'payload_too_large': {
    code: 'PAYLOAD_TOO_LARGE',
    message: '消息体过大',
    suggestion: '请减小消息体大小'
  },
  'disconnected': {
    code: 'DISCONNECTED',
    message: '连接已断开',
    suggestion: '请重新连接服务器'
  }
}

export function handleMqttError(error: string): MqttErrorInfo {
  // 尝试匹配已知错误
  for (const [key, info] of Object.entries(mqttErrorMap)) {
    if (error.toLowerCase().includes(key)) {
      errorHandler.handle(info.message, ErrorType.MQTT)
      return info
    }
  }

  // 未知MQTT错误
  const unknownError: MqttErrorInfo = {
    code: 'UNKNOWN',
    message: error,
    suggestion: '请查看详细日志获取更多信息'
  }
  
  errorHandler.handle(error, ErrorType.MQTT)
  return unknownError
}

export function isMqttConnected(status: string): boolean {
  return status === 'connected'
}

export function getMqttStatusInfo(status: string): { text: string; type: string } {
  const statusMap: Record<string, { text: string; type: string }> = {
    'disconnected': { text: '未连接', type: 'info' },
    'connecting': { text: '连接中...', type: 'warning' },
    'connected': { text: '已连接', type: 'success' },
    'reconnecting': { text: '重连中...', type: 'warning' },
    'error': { text: '连接错误', type: 'danger' }
  }
  
  return statusMap[status] || { text: status, type: 'info' }
}
```

---

## 3. 用户体验优化

### 3.1 加载状态组件

### 文件：`src/components/common/LoadingOverlay.vue`

```vue
<template>
  <transition name="fade">
    <div v-if="visible" class="loading-overlay">
      <div class="loading-content">
        <el-icon class="loading-icon"><Loading /></el-icon>
        <p v-if="text" class="loading-text">{{ text }}</p>
      </div>
    </div>
  </transition>
</template>

<script setup lang="ts">
import { Loading } from '@element-plus/icons-vue'

defineProps<{
  visible: boolean
  text?: string
}>()
</script>

<style scoped>
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.8);
  z-index: 100;
}

.dark .loading-overlay {
  background: rgba(0, 0, 0, 0.6);
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.loading-icon {
  font-size: 32px;
  color: var(--el-color-primary);
  animation: rotate 1s linear infinite;
}

.loading-text {
  margin: 0;
  color: var(--el-text-color-secondary);
  font-size: 14px;
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

### 3.2 确认对话框组合式函数

### 文件：`src/composables/useConfirm.ts`

```typescript
import { ElMessageBox, type ElMessageBoxOptions } from 'element-plus'

interface ConfirmOptions {
  title?: string
  message: string
  type?: 'success' | 'warning' | 'info' | 'error'
  confirmText?: string
  cancelText?: string
  dangerous?: boolean
}

export function useConfirm() {
  async function confirm(options: ConfirmOptions): Promise<boolean> {
    const config: ElMessageBoxOptions = {
      title: options.title || '确认',
      message: options.message,
      type: options.type || 'warning',
      confirmButtonText: options.confirmText || '确定',
      cancelButtonText: options.cancelText || '取消',
      showCancelButton: true
    }

    if (options.dangerous) {
      config.confirmButtonClass = 'el-button--danger'
    }

    try {
      await ElMessageBox(config)
      return true
    } catch {
      return false
    }
  }

  async function confirmDelete(itemName: string): Promise<boolean> {
    return confirm({
      title: '删除确认',
      message: `确定要删除 "${itemName}" 吗？此操作不可撤销。`,
      type: 'warning',
      dangerous: true
    })
  }

  async function confirmDiscard(): Promise<boolean> {
    return confirm({
      title: '放弃更改',
      message: '您有未保存的更改，确定要放弃吗？',
      type: 'warning'
    })
  }

  async function confirmDisconnect(): Promise<boolean> {
    return confirm({
      title: '断开连接',
      message: '确定要断开与服务器的连接吗？',
      type: 'info'
    })
  }

  return {
    confirm,
    confirmDelete,
    confirmDiscard,
    confirmDisconnect
  }
}
```

### 3.3 快捷键支持

### 文件：`src/composables/useKeyboard.ts`

```typescript
import { onMounted, onUnmounted } from 'vue'

interface KeyboardShortcut {
  key: string
  ctrl?: boolean
  shift?: boolean
  alt?: boolean
  handler: () => void
  description: string
}

const registeredShortcuts: KeyboardShortcut[] = []

export function useKeyboard(shortcuts: KeyboardShortcut[]) {
  function handleKeydown(event: KeyboardEvent) {
    for (const shortcut of shortcuts) {
      const ctrlMatch = shortcut.ctrl ? event.ctrlKey || event.metaKey : !event.ctrlKey && !event.metaKey
      const shiftMatch = shortcut.shift ? event.shiftKey : !event.shiftKey
      const altMatch = shortcut.alt ? event.altKey : !event.altKey
      const keyMatch = event.key.toLowerCase() === shortcut.key.toLowerCase()

      if (ctrlMatch && shiftMatch && altMatch && keyMatch) {
        event.preventDefault()
        shortcut.handler()
        break
      }
    }
  }

  onMounted(() => {
    shortcuts.forEach(s => registeredShortcuts.push(s))
    window.addEventListener('keydown', handleKeydown)
  })

  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeydown)
    shortcuts.forEach(s => {
      const index = registeredShortcuts.indexOf(s)
      if (index > -1) {
        registeredShortcuts.splice(index, 1)
      }
    })
  })
}

// 获取所有注册的快捷键（用于显示帮助）
export function getRegisteredShortcuts(): KeyboardShortcut[] {
  return [...registeredShortcuts]
}

// 格式化快捷键显示
export function formatShortcut(shortcut: KeyboardShortcut): string {
  const parts: string[] = []
  
  if (shortcut.ctrl) {
    parts.push('Ctrl')
  }
  if (shortcut.shift) {
    parts.push('Shift')
  }
  if (shortcut.alt) {
    parts.push('Alt')
  }
  parts.push(shortcut.key.toUpperCase())
  
  return parts.join(' + ')
}
```

### 3.4 主页面快捷键配置

### 文件：`src/views/MainView.vue` (部分代码)

```vue
<script setup lang="ts">
import { useKeyboard } from '@/composables/useKeyboard'
import { useConnectionStore } from '@/stores/connection'

const connectionStore = useConnectionStore()

// 注册快捷键
useKeyboard([
  {
    key: 'n',
    ctrl: true,
    handler: () => {
      // 新建连接
      showNewConnectionDialog.value = true
    },
    description: '新建连接'
  },
  {
    key: 'd',
    ctrl: true,
    handler: () => {
      // 断开连接
      if (connectionStore.currentConnection) {
        connectionStore.disconnect()
      }
    },
    description: '断开连接'
  },
  {
    key: 'p',
    ctrl: true,
    handler: () => {
      // 发布消息
      focusPublishInput()
    },
    description: '发布消息'
  },
  {
    key: 'l',
    ctrl: true,
    handler: () => {
      // 清空消息
      clearMessages()
    },
    description: '清空消息'
  },
  {
    key: ',',
    ctrl: true,
    handler: () => {
      // 设置
      showSettingsDialog.value = true
    },
    description: '打开设置'
  }
])
</script>
```

---

## 4. 应用设置

### 文件：`src/stores/settings.ts`

```typescript
import { defineStore } from 'pinia'
import { ref, watch } from 'vue'
import { invoke } from '@tauri-apps/api/core'

export interface AppSettings {
  // 外观
  theme: 'light' | 'dark' | 'system'
  fontSize: number
  
  // 消息
  maxMessages: number
  autoScroll: boolean
  showTimestamp: boolean
  timestampFormat: string
  
  // 连接
  autoReconnect: boolean
  reconnectInterval: number
  keepAlive: number
  
  // 编辑器
  defaultPayloadType: 'json' | 'text' | 'hex'
  jsonIndent: number
  wordWrap: boolean
}

const defaultSettings: AppSettings = {
  theme: 'system',
  fontSize: 14,
  maxMessages: 1000,
  autoScroll: true,
  showTimestamp: true,
  timestampFormat: 'HH:mm:ss.SSS',
  autoReconnect: true,
  reconnectInterval: 5000,
  keepAlive: 60,
  defaultPayloadType: 'json',
  jsonIndent: 2,
  wordWrap: true
}

export const useSettingsStore = defineStore('settings', () => {
  const settings = ref<AppSettings>({ ...defaultSettings })
  const loaded = ref(false)

  // 加载设置
  async function loadSettings() {
    try {
      const saved = await invoke<string | null>('get_setting', { key: 'app_settings' })
      if (saved) {
        const parsed = JSON.parse(saved)
        settings.value = { ...defaultSettings, ...parsed }
      }
      loaded.value = true
    } catch (error) {
      console.error('加载设置失败:', error)
    }
  }

  // 保存设置
  async function saveSettings() {
    try {
      await invoke('set_setting', {
        key: 'app_settings',
        value: JSON.stringify(settings.value)
      })
    } catch (error) {
      console.error('保存设置失败:', error)
    }
  }

  // 更新设置
  function updateSettings(partial: Partial<AppSettings>) {
    settings.value = { ...settings.value, ...partial }
  }

  // 重置设置
  function resetSettings() {
    settings.value = { ...defaultSettings }
  }

  // 监听设置变化自动保存
  watch(settings, () => {
    if (loaded.value) {
      saveSettings()
    }
  }, { deep: true })

  return {
    settings,
    loaded,
    loadSettings,
    saveSettings,
    updateSettings,
    resetSettings
  }
})
```

### 文件：`src/components/settings/SettingsDialog.vue`

```vue
<template>
  <el-dialog
    v-model="visible"
    title="设置"
    width="600px"
    destroy-on-close
  >
    <el-tabs v-model="activeTab">
      <!-- 外观设置 -->
      <el-tab-pane label="外观" name="appearance">
        <el-form label-width="120px">
          <el-form-item label="主题">
            <el-radio-group v-model="settings.theme">
              <el-radio value="light">浅色</el-radio>
              <el-radio value="dark">深色</el-radio>
              <el-radio value="system">跟随系统</el-radio>
            </el-radio-group>
          </el-form-item>
          <el-form-item label="字体大小">
            <el-slider
              v-model="settings.fontSize"
              :min="12"
              :max="20"
              :step="1"
              show-input
            />
          </el-form-item>
        </el-form>
      </el-tab-pane>

      <!-- 消息设置 -->
      <el-tab-pane label="消息" name="messages">
        <el-form label-width="120px">
          <el-form-item label="最大消息数">
            <el-input-number
              v-model="settings.maxMessages"
              :min="100"
              :max="10000"
              :step="100"
            />
          </el-form-item>
          <el-form-item label="自动滚动">
            <el-switch v-model="settings.autoScroll" />
          </el-form-item>
          <el-form-item label="显示时间戳">
            <el-switch v-model="settings.showTimestamp" />
          </el-form-item>
          <el-form-item v-if="settings.showTimestamp" label="时间格式">
            <el-input v-model="settings.timestampFormat" />
          </el-form-item>
        </el-form>
      </el-tab-pane>

      <!-- 连接设置 -->
      <el-tab-pane label="连接" name="connection">
        <el-form label-width="120px">
          <el-form-item label="自动重连">
            <el-switch v-model="settings.autoReconnect" />
          </el-form-item>
          <el-form-item v-if="settings.autoReconnect" label="重连间隔(ms)">
            <el-input-number
              v-model="settings.reconnectInterval"
              :min="1000"
              :max="60000"
              :step="1000"
            />
          </el-form-item>
          <el-form-item label="Keep Alive(s)">
            <el-input-number
              v-model="settings.keepAlive"
              :min="10"
              :max="300"
            />
          </el-form-item>
        </el-form>
      </el-tab-pane>

      <!-- 编辑器设置 -->
      <el-tab-pane label="编辑器" name="editor">
        <el-form label-width="120px">
          <el-form-item label="默认消息类型">
            <el-radio-group v-model="settings.defaultPayloadType">
              <el-radio value="json">JSON</el-radio>
              <el-radio value="text">纯文本</el-radio>
              <el-radio value="hex">HEX</el-radio>
            </el-radio-group>
          </el-form-item>
          <el-form-item label="JSON缩进">
            <el-radio-group v-model="settings.jsonIndent">
              <el-radio :value="2">2空格</el-radio>
              <el-radio :value="4">4空格</el-radio>
            </el-radio-group>
          </el-form-item>
          <el-form-item label="自动换行">
            <el-switch v-model="settings.wordWrap" />
          </el-form-item>
        </el-form>
      </el-tab-pane>
    </el-tabs>

    <template #footer>
      <el-button @click="handleReset">恢复默认</el-button>
      <el-button type="primary" @click="visible = false">完成</el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { ElMessageBox, ElMessage } from 'element-plus'
import { useSettingsStore } from '@/stores/settings'

const props = defineProps<{
  modelValue: boolean
}>()

const emit = defineEmits<{
  'update:modelValue': [value: boolean]
}>()

const settingsStore = useSettingsStore()

const visible = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value)
})

const activeTab = ref('appearance')
const settings = computed(() => settingsStore.settings)

async function handleReset() {
  try {
    await ElMessageBox.confirm(
      '确定要恢复所有设置为默认值吗？',
      '恢复默认设置',
      { type: 'warning' }
    )
    settingsStore.resetSettings()
    ElMessage.success('设置已恢复默认')
  } catch {
    // 用户取消
  }
}
</script>
```

---

## 5. 应用打包

### 5.1 Tauri配置更新

### 文件：`src-tauri/tauri.conf.json`

```json
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "Mini MQTT Client",
  "version": "1.0.0",
  "identifier": "com.minimqtt.client",
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:5173",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "Mini MQTT Client",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600,
        "center": true,
        "resizable": true,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": ["msi", "nsis"],
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "windows": {
      "certificateThumbprint": null,
      "digestAlgorithm": "sha256",
      "timestampUrl": ""
    }
  }
}
```

### 5.2 打包脚本

### 文件：`package.json` (scripts部分)

```json
{
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc --noEmit && vite build",
    "preview": "vite preview",
    "tauri": "tauri",
    "tauri:dev": "tauri dev",
    "tauri:build": "tauri build",
    "lint": "eslint . --ext .vue,.js,.ts,.tsx --fix",
    "format": "prettier --write src/"
  }
}
```

---

## 验收标准

1. 大量消息时界面流畅
2. 错误信息友好且有指导意义
3. 快捷键功能正常
4. 设置保存和加载正常
5. 应用可正常打包为Windows安装包
6. 整体用户体验良好

## 项目完成

至此，Mini MQTT Client所有开发阶段完成。请参考各阶段进度文档记录开发过程中的问题和解决方案。
