# 阶段四：发布/订阅功能

## 概述

本阶段实现 MQTT 消息的发布和订阅核心功能，包括主题管理、消息发送、订阅管理等。

## 任务清单

### 4.1 订阅管理

- [ ] 实现订阅列表组件
- [ ] 实现添加/删除订阅功能
- [ ] 实现 QoS 级别选择
- [ ] 实现订阅持久化存储

### 4.2 消息发布

- [ ] 实现消息发布表单
- [ ] 支持多种消息格式（JSON/HEX/纯文本）
- [ ] 实现 QoS 和 Retain 选项
- [ ] 实现发布历史记录

### 4.3 消息接收处理

- [ ] 实现消息接收回调
- [ ] 实现消息格式自动检测
- [ ] 实现消息存储到文件

---

## 详细实现

### 4.1 Rust 订阅管理命令

**文件：`src-tauri/src/commands/subscription.rs`**

```rust
use crate::db::models::Subscription;
use crate::db::Storage;
use crate::mqtt::MqttManager;
use tauri::State;

#[tauri::command]
pub async fn add_subscription(
    storage: State<'_, Storage>,
    mqtt_manager: State<'_, MqttManager>,
    server_id: i64,
    topic: String,
    qos: i32,
) -> Result<Subscription, String> {
    // 创建订阅
    let sub = Subscription {
        id: None,
        server_id,
        topic: topic.clone(),
        qos,
        is_active: true,
        created_at: None,
    };

    let subscription = storage.create_subscription(sub)?;

    // 如果已连接，则订阅主题
    if mqtt_manager.is_connected(server_id) {
        mqtt_manager
            .subscribe(server_id, topic, qos as u8)
            .await
            .map_err(|e| e.to_string())?;
    }

    Ok(subscription)
}

#[tauri::command]
pub async fn remove_subscription(
    storage: State<'_, Storage>,
    mqtt_manager: State<'_, MqttManager>,
    subscription_id: i64,
    server_id: i64,
    topic: String,
) -> Result<(), String> {
    // 如果已连接，则取消订阅
    if mqtt_manager.is_connected(server_id) {
        mqtt_manager
            .unsubscribe(server_id, topic)
            .await
            .map_err(|e| e.to_string())?;
    }

    // 从存储删除
    storage.delete_subscription(subscription_id)
}

#[tauri::command]
pub async fn get_subscriptions(
    storage: State<'_, Storage>,
    server_id: i64,
) -> Result<Vec<Subscription>, String> {
    Ok(storage.get_subscriptions(server_id))
}

#[tauri::command]
pub async fn toggle_subscription(
    storage: State<'_, Storage>,
    mqtt_manager: State<'_, MqttManager>,
    subscription_id: i64,
    server_id: i64,
    topic: String,
    qos: i32,
    is_active: bool,
) -> Result<(), String> {
    // 更新存储状态
    storage.update_subscription_status(subscription_id, is_active)?;

    // 执行订阅/取消订阅操作
    if mqtt_manager.is_connected(server_id) {
        if is_active {
            mqtt_manager
                .subscribe(server_id, topic, qos as u8)
                .await
                .map_err(|e| e.to_string())?;
        } else {
            mqtt_manager
                .unsubscribe(server_id, topic)
                .await
                .map_err(|e| e.to_string())?;
        }
    }

    Ok(())
}
```

### 4.2 Rust 消息发布命令

**文件：`src-tauri/src/commands/publish.rs`**

```rust
use crate::db::models::{MessageHistory, PublishPayload};
use crate::db::Storage;
use crate::mqtt::MqttManager;
use tauri::State;

#[tauri::command]
pub async fn publish_message(
    storage: State<'_, Storage>,
    mqtt_manager: State<'_, MqttManager>,
    server_id: i64,
    message: PublishPayload,
) -> Result<MessageHistory, String> {
    // 转换消息内容
    let payload_bytes = match message.format.as_str() {
        "hex" => hex::decode(message.payload.replace(" ", ""))
            .map_err(|e| format!("HEX解码失败: {}", e))?,
        _ => message.payload.as_bytes().to_vec(),
    };

    // 发布消息
    mqtt_manager
        .publish(
            server_id,
            message.topic.clone(),
            payload_bytes,
            message.qos as u8,
            message.retain,
        )
        .await
        .map_err(|e| e.to_string())?;

    // 保存到历史记录
    let history = MessageHistory {
        id: None,
        server_id,
        topic: message.topic,
        payload: Some(message.payload),
        payload_format: Some(message.format),
        direction: "publish".to_string(),
        qos: message.qos,
        retain: message.retain,
        created_at: None,
    };

    storage.create_message(history)
}

#[tauri::command]
pub async fn get_message_history(
    storage: State<'_, Storage>,
    server_id: i64,
    limit: Option<usize>,
) -> Result<Vec<MessageHistory>, String> {
    Ok(storage.get_messages(server_id, limit.unwrap_or(100)))
}

#[tauri::command]
pub async fn clear_message_history(
    storage: State<'_, Storage>,
    server_id: i64,
) -> Result<(), String> {
    storage.clear_messages(server_id)
}
```

### 4.3 Storage 操作扩展

**文件：`src-tauri/src/db/mod.rs`（扩展）**

Storage 模块已包含订阅和消息历史的 CRUD 操作方法：

```rust
impl Storage {
    // 订阅相关操作
    pub fn get_subscriptions(&self, server_id: i64) -> Vec<Subscription>;
    pub fn create_subscription(&self, sub: Subscription) -> Result<Subscription, String>;
    pub fn update_subscription_status(&self, id: i64, is_active: bool) -> Result<(), String>;
    pub fn delete_subscription(&self, id: i64) -> Result<(), String>;

    // 消息历史相关操作
    pub fn get_messages(&self, server_id: i64, limit: usize) -> Vec<MessageHistory>;
    pub fn create_message(&self, msg: MessageHistory) -> Result<MessageHistory, String>;
    pub fn clear_messages(&self, server_id: i64) -> Result<(), String>;
}
```

数据保存在 `{AppData}/mini-mqtt-client/data.yaml` 文件中。

### 4.4 前端订阅 Store

**文件：`src/stores/subscription.ts`**

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { invoke } from '@tauri-apps/api/core'
import type { Subscription } from '@/types/mqtt'

export const useSubscriptionStore = defineStore('subscription', () => {
  const subscriptions = ref<Map<number, Subscription[]>>(new Map())
  const loading = ref(false)

  const getSubscriptionsByServer = computed(() => {
    return (serverId: number) => subscriptions.value.get(serverId) || []
  })

  async function fetchSubscriptions(serverId: number) {
    loading.value = true
    try {
      const result = await invoke<Subscription[]>('get_subscriptions', { serverId })
      subscriptions.value.set(serverId, result)
    } finally {
      loading.value = false
    }
  }

  async function addSubscription(serverId: number, topic: string, qos: number) {
    const result = await invoke<Subscription>('add_subscription', {
      serverId,
      topic,
      qos,
    })
    
    const serverSubs = subscriptions.value.get(serverId) || []
    serverSubs.unshift(result)
    subscriptions.value.set(serverId, serverSubs)
    
    return result
  }

  async function removeSubscription(subscriptionId: number, serverId: number, topic: string) {
    await invoke('remove_subscription', {
      subscriptionId,
      serverId,
      topic,
    })
    
    const serverSubs = subscriptions.value.get(serverId) || []
    const index = serverSubs.findIndex(s => s.id === subscriptionId)
    if (index !== -1) {
      serverSubs.splice(index, 1)
      subscriptions.value.set(serverId, serverSubs)
    }
  }

  async function toggleSubscription(
    subscriptionId: number,
    serverId: number,
    topic: string,
    qos: number,
    isActive: boolean
  ) {
    await invoke('toggle_subscription', {
      subscriptionId,
      serverId,
      topic,
      qos,
      isActive,
    })
    
    const serverSubs = subscriptions.value.get(serverId) || []
    const sub = serverSubs.find(s => s.id === subscriptionId)
    if (sub) {
      sub.is_active = isActive
    }
  }

  return {
    subscriptions,
    loading,
    getSubscriptionsByServer,
    fetchSubscriptions,
    addSubscription,
    removeSubscription,
    toggleSubscription,
  }
})
```

### 4.5 前端消息 Store

**文件：`src/stores/message.ts`**

```typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { invoke } from '@tauri-apps/api/core'
import type { MessageHistory, PublishPayload } from '@/types/mqtt'

export const useMessageStore = defineStore('message', () => {
  const messages = ref<Map<number, MessageHistory[]>>(new Map())
  const realtimeMessages = ref<Map<number, MessageHistory[]>>(new Map())
  const loading = ref(false)

  async function fetchMessageHistory(serverId: number, limit = 100, offset = 0) {
    loading.value = true
    try {
      const result = await invoke<MessageHistory[]>('get_message_history', {
        serverId,
        limit,
        offset,
      })
      messages.value.set(serverId, result)
    } finally {
      loading.value = false
    }
  }

  async function publishMessage(serverId: number, message: PublishPayload) {
    const result = await invoke<MessageHistory>('publish_message', {
      serverId,
      message,
    })
    
    // 添加到消息列表
    addMessage(serverId, result)
    
    return result
  }

  function addMessage(serverId: number, message: MessageHistory) {
    const serverMessages = messages.value.get(serverId) || []
    serverMessages.unshift(message)
    
    // 限制消息数量
    if (serverMessages.length > 1000) {
      serverMessages.pop()
    }
    
    messages.value.set(serverId, serverMessages)
    
    // 同时更新实时消息列表
    const realtimeMsgs = realtimeMessages.value.get(serverId) || []
    realtimeMsgs.unshift(message)
    if (realtimeMsgs.length > 100) {
      realtimeMsgs.pop()
    }
    realtimeMessages.value.set(serverId, realtimeMsgs)
  }

  async function clearHistory(serverId: number) {
    await invoke('clear_message_history', { serverId })
    messages.value.set(serverId, [])
    realtimeMessages.value.set(serverId, [])
  }

  function getMessages(serverId: number) {
    return messages.value.get(serverId) || []
  }

  function getRealtimeMessages(serverId: number) {
    return realtimeMessages.value.get(serverId) || []
  }

  return {
    messages,
    realtimeMessages,
    loading,
    fetchMessageHistory,
    publishMessage,
    addMessage,
    clearHistory,
    getMessages,
    getRealtimeMessages,
  }
})
```

### 4.6 订阅列表组件

**文件：`src/components/mqtt/SubscriptionList.vue`**

```vue
<template>
  <div class="subscription-list">
    <div class="subscription-header">
      <span class="title">订阅列表</span>
      <el-button type="primary" size="small" @click="showAddDialog = true">
        添加订阅
      </el-button>
    </div>

    <div class="subscription-items">
      <div
        v-for="sub in subscriptions"
        :key="sub.id"
        class="subscription-item"
        :class="{ inactive: !sub.is_active }"
      >
        <div class="sub-info">
          <el-switch
            :model-value="sub.is_active"
            size="small"
            @change="handleToggle(sub, $event as boolean)"
          />
          <span class="topic" :title="sub.topic">{{ sub.topic }}</span>
          <el-tag size="small" type="info">QoS {{ sub.qos }}</el-tag>
        </div>
        <el-button
          type="danger"
          size="small"
          text
          @click="handleRemove(sub)"
        >
          删除
        </el-button>
      </div>

      <el-empty v-if="subscriptions.length === 0" description="暂无订阅" />
    </div>

    <!-- 添加订阅对话框 -->
    <el-dialog
      v-model="showAddDialog"
      title="添加订阅"
      width="400px"
    >
      <el-form :model="newSubscription" label-width="80px">
        <el-form-item label="主题">
          <el-input
            v-model="newSubscription.topic"
            placeholder="输入订阅主题，支持通配符 + 和 #"
          />
        </el-form-item>
        <el-form-item label="QoS">
          <el-radio-group v-model="newSubscription.qos">
            <el-radio :value="0">QoS 0</el-radio>
            <el-radio :value="1">QoS 1</el-radio>
            <el-radio :value="2">QoS 2</el-radio>
          </el-radio-group>
        </el-form-item>
      </el-form>
      <template #footer>
        <el-button @click="showAddDialog = false">取消</el-button>
        <el-button type="primary" @click="handleAdd" :loading="adding">
          确定
        </el-button>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { useSubscriptionStore } from '@/stores/subscription'
import type { Subscription } from '@/types/mqtt'

const props = defineProps<{
  serverId: number
}>()

const subscriptionStore = useSubscriptionStore()

const subscriptions = computed(() => 
  subscriptionStore.getSubscriptionsByServer(props.serverId)
)

const showAddDialog = ref(false)
const adding = ref(false)
const newSubscription = ref({
  topic: '',
  qos: 0,
})

async function handleAdd() {
  if (!newSubscription.value.topic.trim()) {
    ElMessage.warning('请输入订阅主题')
    return
  }

  adding.value = true
  try {
    await subscriptionStore.addSubscription(
      props.serverId,
      newSubscription.value.topic,
      newSubscription.value.qos
    )
    ElMessage.success('订阅成功')
    showAddDialog.value = false
    newSubscription.value = { topic: '', qos: 0 }
  } catch (error) {
    ElMessage.error(`订阅失败: ${error}`)
  } finally {
    adding.value = false
  }
}

async function handleRemove(sub: Subscription) {
  try {
    await ElMessageBox.confirm(
      `确定要取消订阅 "${sub.topic}" 吗？`,
      '确认删除',
      { type: 'warning' }
    )
    
    await subscriptionStore.removeSubscription(sub.id, props.serverId, sub.topic)
    ElMessage.success('已取消订阅')
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error(`操作失败: ${error}`)
    }
  }
}

async function handleToggle(sub: Subscription, isActive: boolean) {
  try {
    await subscriptionStore.toggleSubscription(
      sub.id,
      props.serverId,
      sub.topic,
      sub.qos,
      isActive
    )
    ElMessage.success(isActive ? '已恢复订阅' : '已暂停订阅')
  } catch (error) {
    ElMessage.error(`操作失败: ${error}`)
  }
}
</script>

<style scoped>
.subscription-list {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.subscription-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--el-border-color);
}

.title {
  font-weight: 600;
  font-size: 14px;
}

.subscription-items {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.subscription-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 4px;
  border-radius: 6px;
  background-color: var(--el-fill-color-light);
  transition: all 0.2s;
}

.subscription-item:hover {
  background-color: var(--el-fill-color);
}

.subscription-item.inactive {
  opacity: 0.6;
}

.sub-info {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.topic {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-family: monospace;
  font-size: 13px;
}
</style>
```

### 4.7 消息发布组件

**文件：`src/components/mqtt/PublishForm.vue`**

```vue
<template>
  <div class="publish-form">
    <div class="form-header">
      <span class="title">发布消息</span>
    </div>

    <el-form :model="form" label-position="top" size="default">
      <el-form-item label="主题">
        <el-input
          v-model="form.topic"
          placeholder="输入发布主题"
          clearable
        >
          <template #append>
            <el-dropdown @command="selectRecentTopic">
              <el-button>
                历史
              </el-button>
              <template #dropdown>
                <el-dropdown-menu>
                  <el-dropdown-item
                    v-for="topic in recentTopics"
                    :key="topic"
                    :command="topic"
                  >
                    {{ topic }}
                  </el-dropdown-item>
                  <el-dropdown-item v-if="recentTopics.length === 0" disabled>
                    暂无历史
                  </el-dropdown-item>
                </el-dropdown-menu>
              </template>
            </el-dropdown>
          </template>
        </el-input>
      </el-form-item>

      <el-form-item label="消息内容">
        <div class="payload-editor">
          <div class="editor-toolbar">
            <el-radio-group v-model="form.format" size="small">
              <el-radio-button value="text">纯文本</el-radio-button>
              <el-radio-button value="json">JSON</el-radio-button>
              <el-radio-button value="hex">HEX</el-radio-button>
            </el-radio-group>
            <el-button
              v-if="form.format === 'json'"
              size="small"
              text
              @click="formatJson"
            >
              格式化
            </el-button>
          </div>
          <el-input
            v-model="form.payload"
            type="textarea"
            :rows="6"
            placeholder="输入消息内容"
            :class="{ 'mono-font': form.format !== 'text' }"
          />
        </div>
      </el-form-item>

      <div class="form-options">
        <el-form-item label="QoS">
          <el-radio-group v-model="form.qos" size="small">
            <el-radio-button :value="0">0</el-radio-button>
            <el-radio-button :value="1">1</el-radio-button>
            <el-radio-button :value="2">2</el-radio-button>
          </el-radio-group>
        </el-form-item>

        <el-form-item label="Retain">
          <el-switch v-model="form.retain" />
        </el-form-item>
      </div>

      <el-form-item>
        <el-button
          type="primary"
          :loading="publishing"
          :disabled="!canPublish"
          @click="handlePublish"
          style="width: 100%"
        >
          发布
        </el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import { useMessageStore } from '@/stores/message'
import { useMqttStore } from '@/stores/mqtt'

const props = defineProps<{
  serverId: number
}>()

const messageStore = useMessageStore()
const mqttStore = useMqttStore()

const form = ref({
  topic: '',
  payload: '',
  qos: 0,
  retain: false,
  format: 'text' as 'text' | 'json' | 'hex',
})

const publishing = ref(false)
const recentTopics = ref<string[]>([])

const isConnected = computed(() => 
  mqttStore.getConnectionStatus(props.serverId) === 'connected'
)

const canPublish = computed(() => 
  isConnected.value && form.value.topic.trim() !== ''
)

function selectRecentTopic(topic: string) {
  form.value.topic = topic
}

function formatJson() {
  try {
    const parsed = JSON.parse(form.value.payload)
    form.value.payload = JSON.stringify(parsed, null, 2)
  } catch {
    ElMessage.warning('无效的 JSON 格式')
  }
}

async function handlePublish() {
  if (!form.value.topic.trim()) {
    ElMessage.warning('请输入主题')
    return
  }

  // 验证 HEX 格式
  if (form.value.format === 'hex') {
    const hexRegex = /^[0-9a-fA-F\s]*$/
    if (!hexRegex.test(form.value.payload)) {
      ElMessage.warning('无效的 HEX 格式')
      return
    }
  }

  // 验证 JSON 格式
  if (form.value.format === 'json' && form.value.payload.trim()) {
    try {
      JSON.parse(form.value.payload)
    } catch {
      ElMessage.warning('无效的 JSON 格式')
      return
    }
  }

  publishing.value = true
  try {
    await messageStore.publishMessage(props.serverId, {
      topic: form.value.topic,
      payload: form.value.payload,
      qos: form.value.qos,
      retain: form.value.retain,
      format: form.value.format,
    })
    
    // 添加到历史主题
    if (!recentTopics.value.includes(form.value.topic)) {
      recentTopics.value.unshift(form.value.topic)
      if (recentTopics.value.length > 10) {
        recentTopics.value.pop()
      }
    }
    
    ElMessage.success('消息已发布')
  } catch (error) {
    ElMessage.error(`发布失败: ${error}`)
  } finally {
    publishing.value = false
  }
}
</script>

<style scoped>
.publish-form {
  padding: 16px;
}

.form-header {
  margin-bottom: 16px;
}

.title {
  font-weight: 600;
  font-size: 14px;
}

.payload-editor {
  width: 100%;
}

.editor-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.form-options {
  display: flex;
  gap: 24px;
}

.mono-font :deep(textarea) {
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 13px;
}
</style>
```

### 4.8 类型定义扩展

**文件：`src/types/mqtt.ts`（扩展）**

```typescript
// 订阅类型
export interface Subscription {
  id: number
  server_id: number
  topic: string
  qos: number
  is_active: boolean
  created_at: string
}

// 消息历史类型
export interface MessageHistory {
  id: number
  server_id: number
  topic: string
  payload: string
  payload_format: 'text' | 'json' | 'hex'
  direction: 'publish' | 'receive'
  qos: number
  retain: boolean
  created_at: string
}

// 发布消息载荷
export interface PublishPayload {
  topic: string
  payload: string
  qos: number
  retain: boolean
  format: 'text' | 'json' | 'hex'
}
```

---

## 测试要点

1. **订阅功能测试**
   - 添加新订阅并验证数据库存储
   - 删除订阅并验证取消订阅
   - 切换订阅状态测试
   - 通配符订阅测试（+ 和 #）

2. **发布功能测试**
   - 纯文本消息发布
   - JSON 格式消息发布和验证
   - HEX 格式消息发布和验证
   - QoS 和 Retain 选项测试

3. **消息历史测试**
   - 发布消息自动保存历史
   - 历史记录分页查询
   - 清除历史功能

---

## 完成标准

- [ ] 订阅 CRUD 功能完整可用
- [ ] 消息发布功能正常工作
- [ ] 支持三种消息格式
- [ ] 消息历史正确保存
- [ ] 所有测试用例通过
