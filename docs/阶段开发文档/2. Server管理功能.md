# 阶段二：Server 管理功能

## 目标概述

实现 MQTT Server 配置的完整 CRUD 功能，包括后端接口和前端界面。

## 前置条件

- 阶段一已完成
- 数据库表结构已创建
- 基础布局组件已就绪

## 任务清单

### 2.1 创建 Rust 命令模块结构

#### 任务描述
创建 Tauri 命令的模块结构

#### 新增文件
- `src-tauri/src/commands/mod.rs`
- `src-tauri/src/commands/server.rs`

#### 代码实现

**src-tauri/src/commands/mod.rs**
```rust
pub mod server;
```

**src-tauri/src/commands/server.rs**
```rust
use crate::db::models::MqttServer;
use crate::db::Database;
use tauri::State;

#[tauri::command]
pub async fn get_servers(db: State<'_, Database>) -> Result<Vec<MqttServer>, String> {
    let conn = db.conn.lock().unwrap();
    
    let mut stmt = conn
        .prepare(
            "SELECT id, name, host, port, protocol_version, username, password, 
             client_id, keep_alive, clean_session, use_tls, ca_cert, client_cert, 
             client_key, created_at, updated_at FROM mqtt_servers ORDER BY id DESC"
        )
        .map_err(|e| e.to_string())?;
    
    let servers = stmt
        .query_map([], |row| {
            Ok(MqttServer {
                id: Some(row.get(0)?),
                name: row.get(1)?,
                host: row.get(2)?,
                port: row.get(3)?,
                protocol_version: row.get(4)?,
                username: row.get(5)?,
                password: row.get(6)?,
                client_id: row.get(7)?,
                keep_alive: row.get(8)?,
                clean_session: row.get::<_, i32>(9)? == 1,
                use_tls: row.get::<_, i32>(10)? == 1,
                ca_cert: row.get(11)?,
                client_cert: row.get(12)?,
                client_key: row.get(13)?,
                created_at: row.get(14)?,
                updated_at: row.get(15)?,
            })
        })
        .map_err(|e| e.to_string())?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| e.to_string())?;
    
    Ok(servers)
}

#[tauri::command]
pub async fn create_server(db: State<'_, Database>, server: MqttServer) -> Result<i64, String> {
    let conn = db.conn.lock().unwrap();
    
    conn.execute(
        "INSERT INTO mqtt_servers (name, host, port, protocol_version, username, password, 
         client_id, keep_alive, clean_session, use_tls, ca_cert, client_cert, client_key)
         VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13)",
        rusqlite::params![
            server.name,
            server.host,
            server.port,
            server.protocol_version,
            server.username,
            server.password,
            server.client_id,
            server.keep_alive,
            server.clean_session as i32,
            server.use_tls as i32,
            server.ca_cert,
            server.client_cert,
            server.client_key,
        ],
    )
    .map_err(|e| e.to_string())?;
    
    Ok(conn.last_insert_rowid())
}

#[tauri::command]
pub async fn update_server(db: State<'_, Database>, server: MqttServer) -> Result<(), String> {
    let conn = db.conn.lock().unwrap();
    
    conn.execute(
        "UPDATE mqtt_servers SET 
         name = ?1, host = ?2, port = ?3, protocol_version = ?4, username = ?5, 
         password = ?6, client_id = ?7, keep_alive = ?8, clean_session = ?9, 
         use_tls = ?10, ca_cert = ?11, client_cert = ?12, client_key = ?13,
         updated_at = CURRENT_TIMESTAMP
         WHERE id = ?14",
        rusqlite::params![
            server.name,
            server.host,
            server.port,
            server.protocol_version,
            server.username,
            server.password,
            server.client_id,
            server.keep_alive,
            server.clean_session as i32,
            server.use_tls as i32,
            server.ca_cert,
            server.client_cert,
            server.client_key,
            server.id,
        ],
    )
    .map_err(|e| e.to_string())?;
    
    Ok(())
}

#[tauri::command]
pub async fn delete_server(db: State<'_, Database>, id: i64) -> Result<(), String> {
    let conn = db.conn.lock().unwrap();
    
    conn.execute("DELETE FROM mqtt_servers WHERE id = ?1", [id])
        .map_err(|e| e.to_string())?;
    
    Ok(())
}

#[tauri::command]
pub async fn get_server(db: State<'_, Database>, id: i64) -> Result<Option<MqttServer>, String> {
    let conn = db.conn.lock().unwrap();
    
    let mut stmt = conn
        .prepare(
            "SELECT id, name, host, port, protocol_version, username, password, 
             client_id, keep_alive, clean_session, use_tls, ca_cert, client_cert, 
             client_key, created_at, updated_at FROM mqtt_servers WHERE id = ?1"
        )
        .map_err(|e| e.to_string())?;
    
    let server = stmt
        .query_row([id], |row| {
            Ok(MqttServer {
                id: Some(row.get(0)?),
                name: row.get(1)?,
                host: row.get(2)?,
                port: row.get(3)?,
                protocol_version: row.get(4)?,
                username: row.get(5)?,
                password: row.get(6)?,
                client_id: row.get(7)?,
                keep_alive: row.get(8)?,
                clean_session: row.get::<_, i32>(9)? == 1,
                use_tls: row.get::<_, i32>(10)? == 1,
                ca_cert: row.get(11)?,
                client_cert: row.get(12)?,
                client_key: row.get(13)?,
                created_at: row.get(14)?,
                updated_at: row.get(15)?,
            })
        })
        .optional()
        .map_err(|e| e.to_string())?;
    
    Ok(server)
}
```

#### 修改文件
`src-tauri/src/lib.rs` - 注册命令

```rust
mod commands;
mod db;

use commands::server::*;
use db::Database;
use tauri::Manager;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .setup(|app| {
            let db = Database::new(&app.handle())?;
            app.manage(db);
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            get_servers,
            get_server,
            create_server,
            update_server,
            delete_server,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 验收标准
- 后端命令编译成功
- 命令可通过 invoke 调用

---

### 2.2 创建 TypeScript 类型定义

#### 任务描述
创建与后端对应的 TypeScript 类型

#### 新增文件
`src/types/mqtt.ts`

#### 代码实现
```typescript
export interface MqttServer {
  id?: number;
  name: string;
  host: string;
  port: number;
  protocol_version: "3.1.1" | "5.0";
  username?: string;
  password?: string;
  client_id?: string;
  keep_alive: number;
  clean_session: boolean;
  use_tls: boolean;
  ca_cert?: string;
  client_cert?: string;
  client_key?: string;
  created_at?: string;
  updated_at?: string;
}

export interface CommandTemplate {
  id?: number;
  server_id: number;
  name: string;
  topic: string;
  payload?: string;
  qos: 0 | 1 | 2;
  retain: boolean;
  category?: string;
  created_at?: string;
  updated_at?: string;
}

export interface MqttMessage {
  id?: number;
  server_id: number;
  direction: "publish" | "receive";
  topic: string;
  payload?: Uint8Array;
  qos: 0 | 1 | 2;
  retain: boolean;
  timestamp?: string;
}

export type ConnectionStatus = "disconnected" | "connecting" | "connected" | "error";
```

#### 验收标准
- 类型定义完整
- 与后端数据结构一致

---

### 2.3 创建 Server Store

#### 任务描述
创建管理 Server 状态的 Pinia Store

#### 新增文件
`src/stores/server.ts`

#### 代码实现
```typescript
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import { invoke } from "@tauri-apps/api/core";
import type { MqttServer, ConnectionStatus } from "@/types/mqtt";

export const useServerStore = defineStore("server", () => {
  // Server 列表
  const servers = ref<MqttServer[]>([]);
  
  // 当前选中的 Server ID
  const currentServerId = ref<number | null>(null);
  
  // 连接状态 Map
  const connectionStatus = ref<Map<number, ConnectionStatus>>(new Map());
  
  // 加载状态
  const loading = ref(false);

  // 当前选中的 Server
  const currentServer = computed(() => {
    if (!currentServerId.value) return null;
    return servers.value.find((s) => s.id === currentServerId.value) || null;
  });

  // 获取所有 Server
  const fetchServers = async () => {
    loading.value = true;
    try {
      servers.value = await invoke<MqttServer[]>("get_servers");
    } finally {
      loading.value = false;
    }
  };

  // 创建 Server
  const createServer = async (server: Omit<MqttServer, "id" | "created_at" | "updated_at">) => {
    const id = await invoke<number>("create_server", { server });
    await fetchServers();
    return id;
  };

  // 更新 Server
  const updateServer = async (server: MqttServer) => {
    await invoke("update_server", { server });
    await fetchServers();
  };

  // 删除 Server
  const deleteServer = async (id: number) => {
    await invoke("delete_server", { id });
    if (currentServerId.value === id) {
      currentServerId.value = null;
    }
    await fetchServers();
  };

  // 设置当前 Server
  const setCurrentServer = (id: number | null) => {
    currentServerId.value = id;
  };

  // 设置连接状态
  const setConnectionStatus = (id: number, status: ConnectionStatus) => {
    connectionStatus.value.set(id, status);
  };

  // 获取连接状态
  const getConnectionStatus = (id: number): ConnectionStatus => {
    return connectionStatus.value.get(id) || "disconnected";
  };

  return {
    servers,
    currentServerId,
    currentServer,
    connectionStatus,
    loading,
    fetchServers,
    createServer,
    updateServer,
    deleteServer,
    setCurrentServer,
    setConnectionStatus,
    getConnectionStatus,
  };
});
```

#### 验收标准
- Store 功能完整
- 可以正确调用后端命令

---

### 2.4 创建 Server 列表组件

#### 任务描述
开发左侧边栏的 Server 列表

#### 新增文件
`src/components/mqtt/ServerList.vue`

#### 代码实现
```vue
<template>
  <div class="server-list">
    <div class="list-header">
      <span>Server 列表</span>
      <el-button type="primary" size="small" :icon="Plus" circle @click="showAddDialog" />
    </div>
    
    <el-scrollbar class="list-content">
      <div v-if="serverStore.loading" class="loading-state">
        <el-icon class="is-loading"><Loading /></el-icon>
        <span>加载中...</span>
      </div>
      
      <el-empty v-else-if="serverStore.servers.length === 0" description="暂无 Server" :image-size="60" />
      
      <div v-else class="server-items">
        <div
          v-for="server in serverStore.servers"
          :key="server.id"
          class="server-item"
          :class="{ active: serverStore.currentServerId === server.id }"
          @click="selectServer(server)"
        >
          <div class="server-info">
            <div class="server-name">{{ server.name }}</div>
            <div class="server-host">{{ server.host }}:{{ server.port }}</div>
          </div>
          <div class="server-status">
            <span class="status-dot" :class="getStatusClass(server.id!)" />
          </div>
          <el-dropdown trigger="click" @command="handleCommand($event, server)">
            <el-button :icon="More" size="small" text @click.stop />
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item command="edit">编辑</el-dropdown-item>
                <el-dropdown-item command="delete" divided>删除</el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>
    </el-scrollbar>

    <!-- 新增/编辑对话框 -->
    <ServerFormDialog
      v-model:visible="dialogVisible"
      :server="editingServer"
      @saved="handleSaved"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from "vue";
import { Plus, More, Loading } from "@element-plus/icons-vue";
import { ElMessage, ElMessageBox } from "element-plus";
import { useServerStore } from "@/stores/server";
import ServerFormDialog from "./ServerFormDialog.vue";
import type { MqttServer } from "@/types/mqtt";

const serverStore = useServerStore();
const dialogVisible = ref(false);
const editingServer = ref<MqttServer | null>(null);

onMounted(() => {
  serverStore.fetchServers();
});

const showAddDialog = () => {
  editingServer.value = null;
  dialogVisible.value = true;
};

const selectServer = (server: MqttServer) => {
  serverStore.setCurrentServer(server.id!);
};

const getStatusClass = (id: number) => {
  const status = serverStore.getConnectionStatus(id);
  return {
    connected: status === "connected",
    connecting: status === "connecting",
    error: status === "error",
    disconnected: status === "disconnected",
  };
};

const handleCommand = async (command: string, server: MqttServer) => {
  if (command === "edit") {
    editingServer.value = server;
    dialogVisible.value = true;
  } else if (command === "delete") {
    try {
      await ElMessageBox.confirm(
        `确定要删除 Server "${server.name}" 吗？`,
        "确认删除",
        { type: "warning" }
      );
      await serverStore.deleteServer(server.id!);
      ElMessage.success("删除成功");
    } catch {
      // 用户取消
    }
  }
};

const handleSaved = () => {
  dialogVisible.value = false;
};
</script>

<style scoped lang="scss">
.server-list {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
  font-size: 14px;
  font-weight: 500;
  color: var(--el-text-color-secondary);
}

.list-content {
  flex: 1;
  margin: 0 -12px;
  padding: 0 12px;
}

.loading-state {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 20px;
  color: var(--el-text-color-secondary);
}

.server-items {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.server-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;

  &:hover {
    background-color: var(--el-fill-color-light);
  }

  &.active {
    background-color: var(--el-color-primary-light-9);
  }
}

.server-info {
  flex: 1;
  min-width: 0;
}

.server-name {
  font-size: 14px;
  font-weight: 500;
  color: var(--app-text-color);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.server-host {
  font-size: 12px;
  color: var(--el-text-color-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: var(--el-color-info-light-5);

  &.connected {
    background-color: var(--el-color-success);
  }

  &.connecting {
    background-color: var(--el-color-warning);
    animation: pulse 1.5s infinite;
  }

  &.error {
    background-color: var(--el-color-danger);
  }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}
</style>
```

#### 验收标准
- 列表正确显示所有 Server
- 点击可选中 Server
- 下拉菜单功能正常

---

### 2.5 创建 Server 表单对话框

#### 任务描述
开发 Server 配置的新增/编辑表单

#### 新增文件
`src/components/mqtt/ServerFormDialog.vue`

#### 代码实现
```vue
<template>
  <el-dialog
    :model-value="visible"
    :title="isEdit ? '编辑 Server' : '新增 Server'"
    width="600px"
    destroy-on-close
    @update:model-value="$emit('update:visible', $event)"
  >
    <el-form
      ref="formRef"
      :model="form"
      :rules="rules"
      label-width="100px"
      label-position="right"
    >
      <el-tabs v-model="activeTab">
        <el-tab-pane label="基本配置" name="basic">
          <el-form-item label="名称" prop="name">
            <el-input v-model="form.name" placeholder="请输入名称" />
          </el-form-item>
          
          <el-form-item label="主机地址" prop="host">
            <el-input v-model="form.host" placeholder="例如: broker.emqx.io" />
          </el-form-item>
          
          <el-form-item label="端口" prop="port">
            <el-input-number v-model="form.port" :min="1" :max="65535" />
          </el-form-item>
          
          <el-form-item label="协议版本" prop="protocol_version">
            <el-radio-group v-model="form.protocol_version">
              <el-radio value="3.1.1">MQTT 3.1.1</el-radio>
              <el-radio value="5.0">MQTT 5.0</el-radio>
            </el-radio-group>
          </el-form-item>
          
          <el-form-item label="Client ID" prop="client_id">
            <el-input v-model="form.client_id" placeholder="留空则自动生成">
              <template #append>
                <el-button @click="generateClientId">生成</el-button>
              </template>
            </el-input>
          </el-form-item>
        </el-tab-pane>

        <el-tab-pane label="认证配置" name="auth">
          <el-form-item label="用户名" prop="username">
            <el-input v-model="form.username" placeholder="可选" />
          </el-form-item>
          
          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="可选"
              show-password
            />
          </el-form-item>
        </el-tab-pane>

        <el-tab-pane label="高级配置" name="advanced">
          <el-form-item label="Keep Alive" prop="keep_alive">
            <el-input-number v-model="form.keep_alive" :min="0" :max="65535" />
            <span class="form-tip">秒</span>
          </el-form-item>
          
          <el-form-item label="Clean Session" prop="clean_session">
            <el-switch v-model="form.clean_session" />
          </el-form-item>
          
          <el-form-item label="启用 TLS" prop="use_tls">
            <el-switch v-model="form.use_tls" />
          </el-form-item>
          
          <template v-if="form.use_tls">
            <el-form-item label="CA 证书" prop="ca_cert">
              <el-input
                v-model="form.ca_cert"
                type="textarea"
                :rows="3"
                placeholder="PEM 格式证书内容"
              />
            </el-form-item>
            
            <el-form-item label="客户端证书" prop="client_cert">
              <el-input
                v-model="form.client_cert"
                type="textarea"
                :rows="3"
                placeholder="PEM 格式证书内容（可选）"
              />
            </el-form-item>
            
            <el-form-item label="客户端私钥" prop="client_key">
              <el-input
                v-model="form.client_key"
                type="textarea"
                :rows="3"
                placeholder="PEM 格式私钥内容（可选）"
              />
            </el-form-item>
          </template>
        </el-tab-pane>
      </el-tabs>
    </el-form>

    <template #footer>
      <el-button @click="$emit('update:visible', false)">取消</el-button>
      <el-button type="primary" :loading="saving" @click="handleSave">
        保存
      </el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, watch, computed } from "vue";
import type { FormInstance, FormRules } from "element-plus";
import { ElMessage } from "element-plus";
import { useServerStore } from "@/stores/server";
import type { MqttServer } from "@/types/mqtt";

const props = defineProps<{
  visible: boolean;
  server?: MqttServer | null;
}>();

const emit = defineEmits<{
  "update:visible": [value: boolean];
  saved: [];
}>();

const serverStore = useServerStore();
const formRef = ref<FormInstance>();
const activeTab = ref("basic");
const saving = ref(false);

const isEdit = computed(() => !!props.server?.id);

const defaultForm = (): MqttServer => ({
  name: "",
  host: "",
  port: 1883,
  protocol_version: "3.1.1",
  username: "",
  password: "",
  client_id: "",
  keep_alive: 60,
  clean_session: true,
  use_tls: false,
  ca_cert: "",
  client_cert: "",
  client_key: "",
});

const form = ref<MqttServer>(defaultForm());

const rules: FormRules = {
  name: [{ required: true, message: "请输入名称", trigger: "blur" }],
  host: [{ required: true, message: "请输入主机地址", trigger: "blur" }],
  port: [{ required: true, message: "请输入端口", trigger: "blur" }],
};

watch(
  () => props.visible,
  (val) => {
    if (val) {
      activeTab.value = "basic";
      if (props.server) {
        form.value = { ...props.server };
      } else {
        form.value = defaultForm();
      }
    }
  }
);

const generateClientId = () => {
  form.value.client_id = `mqtt_client_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
};

const handleSave = async () => {
  const valid = await formRef.value?.validate().catch(() => false);
  if (!valid) return;

  saving.value = true;
  try {
    if (isEdit.value) {
      await serverStore.updateServer(form.value);
      ElMessage.success("更新成功");
    } else {
      await serverStore.createServer(form.value);
      ElMessage.success("创建成功");
    }
    emit("saved");
  } catch (error) {
    ElMessage.error(`保存失败: ${error}`);
  } finally {
    saving.value = false;
  }
};
</script>

<style scoped lang="scss">
.form-tip {
  margin-left: 8px;
  color: var(--el-text-color-secondary);
}
</style>
```

#### 验收标准
- 表单验证正常
- 新增/编辑功能正常
- TLS 配置区域条件显示

---

### 2.6 更新侧边栏组件

#### 任务描述
更新 Sidebar 组件以使用 ServerList

#### 修改文件
`src/components/layout/Sidebar.vue`

#### 验收标准
- ServerList 正常显示在侧边栏
- 功能集成完整

---

## 完成检查清单

- [ ] Rust 后端 CRUD 命令实现完成
- [ ] TypeScript 类型定义完成
- [ ] Server Store 创建完成
- [ ] Server 列表组件开发完成
- [ ] Server 表单对话框开发完成
- [ ] 侧边栏集成 ServerList
- [ ] 所有 CRUD 功能测试通过

## 预期产出

1. 完整的 Server 管理后端接口
2. Server 列表界面
3. Server 新增/编辑表单
4. Server 删除确认
5. 数据持久化到 SQLite
